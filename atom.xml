<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心有所向，日复一日，必有精进</title>
  
  <subtitle>欢迎来到ELement_GC的咸鱼博客</subtitle>
  <link href="https://elementgc.github.io/atom.xml" rel="self"/>
  
  <link href="https://elementgc.github.io/"/>
  <updated>2023-05-27T06:14:00.387Z</updated>
  <id>https://elementgc.github.io/</id>
  
  <author>
    <name>Element_GC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库学习笔记</title>
    <link href="https://elementgc.github.io/2023/05/27/data-base-note-1/"/>
    <id>https://elementgc.github.io/2023/05/27/data-base-note-1/</id>
    <published>2023-05-27T05:47:17.000Z</published>
    <updated>2023-05-27T06:14:00.387Z</updated>
    
    <content type="html"><![CDATA[<h1>数据库基本术语</h1><p><strong>数据（Data）</strong></p><p>保存在计算机中，能够背计算机识别、存储、处理的各种符号的统称</p><p><strong>信息（Information）</strong></p><p>经过加工处理过后的数据，是对数据的具体描述</p><p><strong>数据是信息载体，信息是对数据的语义解释</strong></p><p><strong>数据库（Database，DB）</strong></p><p>长期存储在计算机内的、<strong>有组织的</strong>、<strong>可共享的</strong>大量<strong>数据的集合</strong></p><p><strong>数据库管理系统（Database Manage System，DBMS）</strong></p><p>位于<strong>用户与操作系统之间</strong>的一层<strong>数据管理软件</strong>，主要目标是让数据成为方便各种用户使用的资源，提高数据的<strong>安全性、完整性和可用性</strong></p><p><strong>元数据</strong></p><p>描述数据的数据，相当于是表格的<strong>表头</strong>，用来定义每一列的<strong>数据属性</strong>，如数据类型、格式、存储大小等</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p1.png" alt="元数据" width="600" height="300"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据库基本术语&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数据（Data）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保存在计算机中，能够背计算机识别、存储、处理的各种符号的统称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息（Information）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过加工处理过后的</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何将本地资源上传到github的远程仓库</title>
    <link href="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/"/>
    <id>https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/</id>
    <published>2023-05-25T00:26:58.000Z</published>
    <updated>2023-05-26T07:59:11.373Z</updated>
    
    <content type="html"><![CDATA[<h1>常规情况下的操作</h1><h3 id="1-检查当前分支">1. 检查当前分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p1.png" alt="查看当前分支"></p><h3 id="2-将文件添加到缓存区并提交信息">2. 将文件添加到缓存区并提交信息</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;&lt;提交信息&gt;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2.png" alt="git add .结果"><br><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p3.png" alt="git commit 结果"></p><h3 id="3-将更改上传（push）到远程仓库">3.将更改上传（push）到远程仓库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push &lt;为远程仓库在本地起的别名&gt; &lt;远程仓库的分支名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p4.png" alt="git push 命令运行结果"><br><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p5.png" alt="上传结果展示"></p><h1>一些小操作</h1><h3 id="查看git-add-都添加了些什么：">查看<code>git add .</code>都添加了些什么：</h3><p>使用<code>git status</code>来进行查看</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2-1.png" alt="git status 结果"></p><h3 id="查看链接了那些远程仓库">查看链接了那些远程仓库</h3><p>使用<code>git remote</code>进行查看链接的所有远程仓库的别名</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2-2.png" alt="链接的远程仓库别名"><br>使用<code>git remote -v</code>查看远程仓库的地址</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2-3.png" alt="查看远程仓库的地址"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;常规情况下的操作&lt;/h1&gt;
&lt;h3 id=&quot;1-检查当前分支&quot;&gt;1. 检查当前分支&lt;/h3&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git bran</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="git" scheme="https://elementgc.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>配置个人博客的一些相关事项</title>
    <link href="https://elementgc.github.io/2023/05/24/Blog-configuration/"/>
    <id>https://elementgc.github.io/2023/05/24/Blog-configuration/</id>
    <published>2023-05-24T10:33:21.602Z</published>
    <updated>2023-05-26T07:57:05.584Z</updated>
    
    <content type="html"><![CDATA[<h1>ELement——GC的个人博客仓库</h1><h2 id="分支-main">分支-main</h2><p>目前只有一个README，用来帮自己弄懂这个是拿来干嘛的</p><h2 id="hexo">hexo</h2><p>在我们的博客设置文件中，我们设置了</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:ElementGC/ElementGC.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">hexo</span></span><br></pre></td></tr></table></figure><p>这一设置让我们能够将本地静态网站布置好<code> hexo g</code>之后将网站结果保存到对应github仓库的分支<code>hexo</code>中，也就是说，其实github加载的网站就是从hexo分支中弄出来的</p><h2 id="sourcelib">sourcelib</h2><p>这是我为了保险起见加的，毕竟说不定什么时候一不小心本地仓库没了都有可能，所以我把原本的<strong>配置文件</strong>~~<em>这个是重点</em>~~也打包好放上来，实现理论上来说只要安装好<code>git</code>和<code>hexo</code>就可以直接从网上拉取这个包然后一个    <code>hexo g  &amp;&amp; hexo s</code>直接也实现本地配置网页，然后好接着改，所以这玩意得及时更新</p><h1>hexo配置-butterfly主题</h1><p>本博客主要就是基于hexo框架下的butterfly主题建立的博客，因此也会在此详细解释一些比较常用，更加个性化的配置设置</p><h2 id="基本设置">基本设置</h2><h3 id="根目录下的-config-yml文件-hexo官方文档-配置">根目录下的<code>_config.yml</code>文件 <a href="https://hexo.io/zh-cn/docs/configuration">hexo官方文档-配置</a></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#x27;心有所向，日复一日，必有精进&#x27;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;欢迎来到ELement_GC的咸鱼博客&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;欢迎光临，希望你能在这里找到您想要的&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Element_GC</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>title 为网站总标题，就是一点开主页的网址名称，以及该主题下的主页正中间以及导航栏左上角的文字描述</p></li><li class="lvl-2"><p>subtitle 为网站副标题，在 <code>butterfly</code> 主题下一般情况下不会显示，这个主题的配置里面更改设置才会出来</p></li><li class="lvl-2"><p>discription 为网站描述，在 <code>butterfly</code>主题下表现为侧边栏中，作者名字下的签名</p></li><li class="lvl-2"><p>keyword 关键字，没用过</p></li><li class="lvl-2"><p>author 作者，这个肯定得写自己的名字</p></li><li class="lvl-2"><p>language 语言，肯定得写中文啊，不过好像 一开始 <code>hexo init</code>直接生成的配置文件里面是英文，可以改成 <code>zh-CN</code></p></li><li class="lvl-2"><p>timezone 时区，一般以电脑上的时区为准，中国的话直接设成 <code>Asia/Shanghai</code>就行</p></li></ul><p>主页各个部分结构如下图所示<br><img src="https://elementgc.github.io/2023/05/24/Blog-configuration/p1.png" alt="主标题、副标题与导航栏"><br><img src="https://elementgc.github.io/2023/05/24/Blog-configuration/p2.png" alt="头像、作者、与描述"><br><br></p><p>更多的设置可以去<a href="https://hexo.io/zh-cn/docs/configuration">hexo官方文档-配置</a>查看</p><h2 id="插件更新设置">插件更新设置</h2><p>出这么一个的最初原因还是我想调整博客里面图片的大小，然后顺藤摸瓜找到了这篇文档<a href="https://blog.csdn.net/qq_42951560/article/details/123596899">【Hexo】选择更高级的Markdown渲染器</a>，在这里做一个大致的介绍：</p><ol><li class="lvl-3"><p>渲染器的选择：</p></li></ol><p>Hexo 默认搭配的 Markdown 渲染器是 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>，但其支持的渲染格式有限，对于要求多元的博客来说有时候并不是很合适，因此可以改用功能更多的 <a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a> 渲染器，以下是 hexo-renderer-markdown-it 的安装步骤：</p><h3 id="卸载与安装">卸载与安装</h3><p>卸载<code>hexo-renderer-marked</code>渲染器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>安装<code>hexo-renderer-markdown-it</code>渲染器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i markdown-it-checkbox</span><br><span class="line">npm i markdown-it-imsize</span><br><span class="line">npm i markdown-it-expandable</span><br></pre></td></tr></table></figure><p><em>只安装这三个主要是因为其他的插件在安装渲染器的时候就一起安装好了</em></p><h3 id="配置">配置</h3><p>将如下文本复制到<code>hexo</code>根目录的配置文本最底下就行</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&quot;language-&quot;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&quot;“”‘’&quot;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-cjk-breaks</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-deflist</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-mark</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-checkbox</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-imsize</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-expandable</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">success</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">tips</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">warning</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">danger</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&quot;header-anchor&quot;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&quot;left&quot;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&quot;¶&quot;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure><h3 id="插件的用法">插件的用法</h3><p>这里只讲一个已经用上的 <code>markdown-it-imsize</code> 插件</p><p>通常来说，md文本导入图片使用的是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片描述](image.png)</span><br></pre></td></tr></table></figure><p>格式的命令，而这个插件可以通过在地址后面添加尺寸的方式实现图片尺寸的更改，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片描述](image.png =300x200)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，等号<code>=</code>前面必须与地址空开一格，后面必须紧跟着尺寸，而且中间的那个就是字母xyz的<strong>x</strong>，<strong>不是乘号</strong>，</p><p>当然，还有许多有趣的渲染命令，这里就不一一例举了，可以在文档<a href="https://blog.csdn.net/qq_42951560/article/details/123596899">【Hexo】选择更高级的Markdown渲染器</a>中进行查看</p><h2 id="butterfly主题设置">butterfly主题设置</h2><p><code>butterfly</code> 的主题设置可以说非常的丰富多彩，这里只举例几个比较常用的以及我已经用上了的配置（可能有些配置设置我已经改了但我没注意到，那也可以在官网上查看），这里也附上butterfly主页的官方网站——<a href="https://butterfly.js.org/">butterfly官网</a></p><h3 id="基本设置-查看文档">基本设置  <a href="https://butterfly.js.org/posts/4aa8abbe">查看文档</a></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">   <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">   <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="comment"># 列表||fas fa-list ||hide:</span></span><br><span class="line">     <span class="comment">#Music: /music/ || fas fa-music</span></span><br><span class="line">     <span class="comment">#Movie: /movies/ || fas fa-video</span></span><br><span class="line">   <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">   <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>这是导航栏部分的设置，没错，开头那里是可以设置成中文的，每一项都可以一一对应上，不想要可以的直接注释掉。除了主页以外其他页面都有个对应的文件夹的，| | 后面的是图标名，我也不知道还有哪些，有空可以去找找看。至于对应的文件夹在哪……我还真没找到</p><blockquote><p>据官方文档的<a href="https://butterfly.js.org/posts/dc584b87">主题页面</a>说，在文档的根目录执行 <code>hexo new page tags</code>就可以创建新标签页，也就是导航栏对应页面，然后生成的文件位置就在<code>source/tags/index.md</code>。很明显我没弄……</p></blockquote><p>列表后面的| | hide是用于隐藏子目录的，用了之后可以移到对应位置展开子目录（音乐和电影）</p><h3 id="给你的博客加个封面查看文档">给你的博客加个封面<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2">查看文档</a></h3><p>封面的添加有两种方法</p><ul class="lvl-0"><li class="lvl-4"><p>从配置文件来随机添加分配封面</p></li><li class="lvl-4"><p>在博客文档的头部添加封面指引</p></li></ul><p>优先级分别为：</p><blockquote><p>博客文档的头部 &gt; 配置文件分配 &gt; 不设置封面</p></blockquote><ol><li class="lvl-3"><p>配置文件</p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">img/---</span> <span class="comment">#img为butterfly主题路径下的\source\img，后面直接跟该文件夹里面的对应文件即可</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">img/---</span> <span class="comment">#若存在多个这种索引，到时候给文章添加封面就会实行随机添加的方法，当然，第一次执行添加完之后就不会再改了</span></span><br></pre></td></tr></table></figure><blockquote><p>根据最新情况来看，好像如果对文章进行更新的话，使用默认随机标题的文章的封面也会更新成一个随机的</p></blockquote><ol start="2"><li class="lvl-3"><p>md文档头部添加</p></li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:    #必，没写的话会给你分配一个“无题”上去</span><br><span class="line">date:     #必，没写的话会按照默认的时间给你填上去</span><br><span class="line">updated:  #可，没写的话会按照默认的时间给你填上去</span><br><span class="line">tags:     #从这个开始下面的基本都是可要可不要的</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:    #这个就是封面，在这里填上封面的地址就行，格式和配置文档的一样，也是通过那种方式去找（和博客内引用图片的方式一点也不一样）</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line"><span class="section">abcjs:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置一下代码块">设置一下代码块</h3><h4 id="代码块自动换行">代码块自动换行</h4><p>因为有时候代码会超长，在页面宽度不够的情况下一行显示不完，如果不设置的话他底下会出现一个滑动条让你左右滑动，就很麻烦；</p><p>这一步需要设置两个文档，一个是butterfly的配置文件，一个是hexo根目录下的配置文件，一个一个来：</p><p>butterfly内的配置文件,只有这一行需要设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>hexo的配置文件，看你的渲染方法，一般两个都找一找</p><ul class="lvl-0"><li class="lvl-2"><p>highlight 渲染</p></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#&lt;-这里是true就说明用的是这个渲染方法</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment"># &lt;- 改这里</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>prismjs 渲染</p></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>   <span class="comment">#&lt;-这里是true就说明用的是这个渲染方法</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment"># &lt;- 改这里</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="代码块限制高度">代码块限制高度</h4><p>有些博客可能里面有一大堆代码块，但有时候我们根本就不想看这些代码，代码块过长反而会让我们翻得难受，一不小心就翻过了，所以限制代码块的高度是必要的</p><p>我们需要在butterfly的配置文件中找到这一行</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br></pre></td></tr></table></figure><p>然后将<code>false</code>修改成我们想要的最大高度（我自己设置的是300），默认单位是px，要是不知道有多长的话可以用截图工具估一下（一般你电脑截图的时候人都会给你显示截图的长和宽的，那个的单位就是px）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ELement——GC的个人博客仓库&lt;/h1&gt;
&lt;h2 id=&quot;分支-main&quot;&gt;分支-main&lt;/h2&gt;
&lt;p&gt;目前只有一个README，用来帮自己弄懂这个是拿来干嘛的&lt;/p&gt;
&lt;h2 id=&quot;hexo&quot;&gt;hexo&lt;/h2&gt;
&lt;p&gt;在我们的博客设置文件中，我们设置了&lt;/</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客" scheme="https://elementgc.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>RFID防冲突算法实验报告</title>
    <link href="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/"/>
    <id>https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/</id>
    <published>2023-05-24T03:47:14.099Z</published>
    <updated>2023-05-27T06:12:14.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实验目的和要求">1. 实验目的和要求</h2><p>（1） 掌握RFID工作原理</p><p>（2）掌握RFID标签冲突产生原理</p><p>（3）掌握常见的RFID防冲突识别算法</p><p>（4）对常见的RFID防冲突识别算法进行实验比较</p><h2 id="2-实验环境">2. 实验环境</h2><p>使用Python语言进行代码的编译与运行，<code>python</code>版本为<code>3.9.13</code>使用的集成开发环境IDE为<code>Pycharm</code>，版本为<code>17.0.5</code>完成实验所需要的数据包为：<code>random</code>数据包，用于生成随机数，分配时隙与标签</p><h2 id="3-实验原理">3. 实验原理</h2><h3 id="3-1-帧时隙ALOHA-FSA-RFID防冲突识别算法：">3.1 帧时隙<code>ALOHA(FSA)</code> RFID防冲突识别算法：</h3><p>将<code>ALOHA</code>算法分为许多时隙，其中若干时隙为一帧，阅读器以帧为单位进行识别。在<code>FSA</code>算法中，每一帧开始时阅读器就广播帧的长度f，指明下一帧所包含的时隙个数，并激活识别区域中的所有标签。每个标签在接收到帧长f之后随机独立地在0~(f-1)中选择一个整数作为自己发送标识符的时隙序号，并将这个序号存在寄存器SN中。在下一帧的每一个时隙中，阅读器通过时隙开始命令启动一个新的时隙，如果标签SN的值为零立即发送标识符号，如果不等于零，则将SN值减一并且不发送标识符。对于标签而言，如果标识符发送成功（即无冲突），则该标签立即进入休眠状态，在之后的时隙中不再活动。如果有冲突发生，则该标签进入等待状态，在下一帧中重新选择一个时隙发送标识符。阅读器不断重复以上过程，直到在某一帧中没有收到任何标签信号，则认为所有标签均被识别。基于上述原理，我们可以得知在FSA算法中存在三种状态的时隙：</p><p>（1）空时隙，即没有标签相应；</p><p>（2）单时隙，即只有一个标签相应；</p><p>（3）冲突时隙，即不只一个标签相应，发生冲突。当且仅当在单时隙中时，阅读器才能成功识别一个标签。我们可以设计出FSA算法流程如下所示：</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p1.png" alt="图1. FSA算法流程图"></p><h3 id="3-2-基于查询二进制树的防冲突算法">3.2 基于查询二进制树的防冲突算法</h3><p>每个标签需要维持一个计数器，计数器初始值为0。在每个时隙开始时，如果标签的计数器为0则立即发送自己的标识符号，否则该时隙不响应。标签识别成功，进入沉默状态，每个时隙结束时阅读器会将接收到的时隙状态反馈给标签，场内的标签根据结束时阅读器反的结果对自己维持的计数器进行调整。因此，对于是否冲突两种情况，也需要做出对应的判断：</p><ol><li class="lvl-3"><p>冲突时隙：参与响应的标签从0/1中随机选择一个，将其加到自己的计数器上；没有参与的标签计数器加1。由此可以将冲突的标签分为两个集合。</p></li><li class="lvl-3"><p>没有冲突：单时隙，成功识别，进入沉默状态，没有被识别的标签自己减1<br>上述算法原理可以简化成下图所示流程<br><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p2.png" alt="图2. 查询二进制树算法流程"></p></li></ol><h2 id="4-实验步骤（包含结果分析和源代码）">4. 实验步骤（包含结果分析和源代码）</h2><h3 id="4-1-帧时隙ALOHA（FSA）RFID防冲突识别算法">4.1 帧时隙ALOHA（FSA）RFID防冲突识别算法:</h3><h4 id="源代码：">源代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 帧参数设置</span></span><br><span class="line">tatal = <span class="number">100</span>  <span class="comment"># 发送时间范围</span></span><br><span class="line">length = <span class="number">1</span>  <span class="comment"># 帧长</span></span><br><span class="line">solt = <span class="number">1</span>  <span class="comment"># 时隙</span></span><br><span class="line">num = <span class="number">100</span>  <span class="comment"># 总帧数</span></span><br><span class="line"><span class="built_in">list</span> = []  <span class="comment"># 用来存放每一个数据帧</span></span><br><span class="line"><span class="comment"># 定义帧类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Frame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, time</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 帧的名字</span></span><br><span class="line">        self.send_time = time  <span class="comment"># 帧的发送时间</span></span><br><span class="line"><span class="comment"># 随机产生每个帧的发送时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="comment"># 帧的名字用序号代替，发送时间都是整数</span></span><br><span class="line">    name = i</span><br><span class="line">    send_time = random.randrange(<span class="number">0</span>, tatal + <span class="number">1</span>, solt)</span><br><span class="line">    frame = Frame(name, send_time)</span><br><span class="line">    <span class="built_in">list</span>.append(frame)</span><br><span class="line"><span class="comment"># 按发送时间属性排序(按时间发送)</span></span><br><span class="line"><span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x.send_time)  <span class="comment"># lambda定义了一个隐含函数x,该函数返回send_time属性</span></span><br><span class="line">success = <span class="number">0</span>  <span class="comment"># 成功发送帧的数量</span></span><br><span class="line">send_frame = [] <span class="comment">#成功发送帧的集合</span></span><br><span class="line">conflict = <span class="number">0</span>  <span class="comment"># 发生冲突即本轮传输失败的帧数量</span></span><br><span class="line"><span class="comment"># 有帧发送、并且发送时间在通信时间内才发送</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">list</span>) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">list</span>[<span class="number">0</span>].send_time &lt;= tatal:</span><br><span class="line">    current_frame = <span class="built_in">list</span>[<span class="number">0</span>]  <span class="comment"># 当前帧一直都是list[0]</span></span><br><span class="line">    <span class="comment"># 冲突检测</span></span><br><span class="line">    address = []  <span class="comment"># 存放冲突帧的name</span></span><br><span class="line">    <span class="comment"># 所有冲突帧存储到address,没有则len(address)=1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">list</span>[i].send_time == current_frame.send_time:</span><br><span class="line">            address.append(i)</span><br><span class="line">    <span class="comment"># 没有冲突,移除列表，同时成功发送帧数量加1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(address) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">list</span>.remove(current_frame)</span><br><span class="line">        send_frame.append(current_frame)</span><br><span class="line">        success += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 发生冲突</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> address:</span><br><span class="line">            <span class="built_in">list</span>[i].send_time += random.randint(<span class="number">1</span>, tatal + <span class="number">1</span>) * solt  <span class="comment"># 延迟发送时间k个时隙</span></span><br><span class="line">        conflict += <span class="number">1</span>  <span class="comment"># 冲突帧的数量加1</span></span><br><span class="line">        <span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x.send_time)  <span class="comment"># 重新排序</span></span><br><span class="line">        address.clear()</span><br><span class="line"><span class="comment"># 计算吞吐率</span></span><br><span class="line">z = success / num</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通信时间:&quot;</span>, tatal, <span class="string">&quot;帧长:&quot;</span>, length)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成功发送的帧数量:<span class="subst">&#123;success&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;发送的帧总数量:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;冲突次数:<span class="subst">&#123;conflict&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;吞吐率:<span class="subst">&#123;z*<span class="number">100</span>&#125;</span>%&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;发送成功的帧分别为&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(send_frame)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;编号：<span class="subst">&#123;send_frame[i].name&#125;</span>；时间：<span class="subst">&#123;send_frame[i].send_time&#125;</span>&quot;</span>,end=<span class="string">&quot;\t\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">6</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果及分析：">运行结果及分析：</h4><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p1.png" alt="图3. "></p><p>在代码运行的过程中，我们对发生冲突的次数进行了统计，观察并记录在规定的时间内（即一定的循环次数内）能够成功发送的帧及其数量，并作为结果进行输出。可以看出，在一定的通信时长内，同样数量的帧总是会发生冲突，导致无法及时完全发送出去，吞吐率往往不及一半。</p><h3 id="4-2-基于查询二进制树的防冲突算法">4.2 基于查询二进制树的防冲突算法</h3><h4 id="源代码">源代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 帧参数设置</span></span><br><span class="line">num = <span class="number">10</span>  <span class="comment"># 总标签数</span></span><br><span class="line"><span class="built_in">list</span> = []  <span class="comment"># 用来存放每一个标签</span></span><br><span class="line">conflict = <span class="number">0</span>  <span class="comment"># 发生冲突即本轮传输失败的帧数量</span></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"><span class="comment"># 定义帧类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 标签名</span></span><br><span class="line">        self.timer = [<span class="number">0</span>]  <span class="comment"># 计数器</span></span><br><span class="line">        self.active = <span class="number">1</span> <span class="comment"># 活跃状态</span></span><br><span class="line"><span class="comment">#检查计数器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Check_Timer</span>(<span class="params">timerA,timerB</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(timerA)):</span><br><span class="line">        <span class="keyword">if</span> timerA[i] != timerB[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#查询二进制树主程序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Check_Lable</span>(<span class="params">boarder,<span class="built_in">list</span></span>):</span><br><span class="line">    same = []</span><br><span class="line">    <span class="keyword">global</span> times</span><br><span class="line">    times += <span class="number">1</span></span><br><span class="line">    insame = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="comment"># if list[i].active : #仅对活跃的标签进行检测</span></span><br><span class="line">        issame = Check_Timer(boarder,<span class="built_in">list</span>[i].timer)</span><br><span class="line">        <span class="keyword">if</span> issame:<span class="comment">#前缀相同,则重新加前缀，记录在案</span></span><br><span class="line">            <span class="built_in">list</span>[i].timer.insert(<span class="number">0</span>,random.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            same.append(<span class="built_in">list</span>[i])</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#前缀不同，另做一个集合</span></span><br><span class="line">            insame.append(<span class="built_in">list</span>[i])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(same) == <span class="number">1</span>:  <span class="comment">#只有一个重复的，就说明这个标签确定对上了</span></span><br><span class="line">        same[<span class="number">0</span>].active = <span class="number">0</span></span><br><span class="line">        same[<span class="number">0</span>].timer.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(same) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment">#前缀加0.继续进行</span></span><br><span class="line">        boarder.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        Check_Lable(boarder,same)<span class="comment"># 冲突的标签拉进去</span></span><br><span class="line">        boarder.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(insame) != <span class="number">0</span>:</span><br><span class="line">        boarder[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        Check_Lable(boarder, insame)</span><br><span class="line"><span class="comment"># 生成每一帧及其计数器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="comment"># 标签的名字用序号代替，发送时间都是整数</span></span><br><span class="line">    name = i</span><br><span class="line">    frame = Lable(name)</span><br><span class="line">    <span class="built_in">list</span>.append(frame)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">fin_res = Check_Lable([<span class="number">0</span>],<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># times = fin_res</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;本次执行共有<span class="subst">&#123;num&#125;</span>个标签&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总共执行次数为<span class="subst">&#123;times&#125;</span>次&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;各个标签的位置分别为:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;序号：<span class="subst">&#123;<span class="built_in">list</span>[i].name&#125;</span>——二进制树坐标：<span class="subst">&#123;<span class="built_in">list</span>[i].timer&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果及分析">运行结果及分析</h4><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p4.png" alt="图4. "></p><p>在该代码中，我们通过类似于构造二叉树的方法建立二进制树，每一帧都进行一次广播并查找有无坐标（即计数器）重复项，若有，则对重复项随机添加前缀并再次广播，直到将全部重复项都区分开来，才算完成，并退回到上一层，就这样逐步分化，最终形成二进制树。</p><h3 id="4-3-分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别">4.3 分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别</h3><p>(1) 10个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p5.png" alt="图5. " width="300" height="300"></p><p>(2)50个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p6.png" alt="图6. " width="300" height="300"></p><p>(3)100个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p7.png" alt="图7. " width="300" height="300"></p><h3 id="4-4-数据表格绘制">4.4 数据表格绘制</h3><table border="2px solid #000" cellspacing="0" cellpadding="0" bordercolor="black" bgcolor="white">    <tr>        <th>标签数量</th>        <th>ALOHA算法</th>        <th>查询二进制树</th>        <th>运行结果</th>    </tr>    <tr align="center">        <td rowspan="3">10</td>        <td>3</td>        <td>10</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>13</td>        <td>20</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>1.3</td>        <td>2</td>        <td>平均识别时长</td>    </tr>    <tr align="center">        <td rowspan="3">50</td>        <td>52</td>        <td>63</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>102</td>        <td>121</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>2.04</td>        <td>2.42</td>        <td>平均识别时长</td>    </tr>    <tr align="center">        <td rowspan="3">100</td>        <td>76</td>        <td>149</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>176</td>        <td>272</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>1.76</td>        <td>2.72</td>        <td>平均识别时长</td>    </tr></table><h3 id="4-5-算法分析">4.5 算法分析</h3><p>如表格所示。我们分别统计并计算了ALOHA算法与查询二进制树算法在标签数量为10、50、100的情况下的冲突次数、通信时间以及平均每个标签的识别市场。可以看出，查询二进制树的平均时长均大于ALOHA算法，并且随着标签数的增长，单个标签识别所需要的时长更长，从而能够看出ALOHA算法相较于查询二进制树算法更加高效。</p><h2 id="实验心得">实验心得</h2><p>在这次实验中，我们深入学习并了解到了基于ALOHA算法与查询二进制树算法的基本原理，了解了在实际通信情况下可能会发生的冲突以及可以选择的解决方法，并根据不同算法原理仿真模拟出在实际通信情况下的两种算法的识别效率，加强了我们对这两种算法的理解。此外，我们还能够通过对比两种算法对于相同数量的通信信号的处理效率，来分析其算法的优劣，同时也能够加以完善，让我们对于这些问题的印象更加深刻，有助于我们学习、分析、了解并实现更多相似的算法及其原理。此外，本次实验还大大强化了我对于python语言的掌握，之前对于python语言的学习仅局限于解决一些具体的数学问题，类似于计算题。而本次实验则是将我们学习的各种方法融合起来，共同实现一个具体的需求，更像一个应用题，这也让我收获颇丰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-实验目的和要求&quot;&gt;1. 实验目的和要求&lt;/h2&gt;
&lt;p&gt;（1） 掌握RFID工作原理&lt;/p&gt;
&lt;p&gt;（2）掌握RFID标签冲突产生原理&lt;/p&gt;
&lt;p&gt;（3）掌握常见的RFID防冲突识别算法&lt;/p&gt;
&lt;p&gt;（4）对常见的RFID防冲突识别算法进行实验比较&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="实验报告" scheme="https://elementgc.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="邮政物联网技术与应用" scheme="https://elementgc.github.io/tags/%E9%82%AE%E6%94%BF%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用的github命令</title>
    <link href="https://elementgc.github.io/2023/05/23/usual-git-command/"/>
    <id>https://elementgc.github.io/2023/05/23/usual-git-command/</id>
    <published>2023-05-23T13:18:04.828Z</published>
    <updated>2023-05-26T07:59:53.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="针对本地仓库的操作">针对本地仓库的操作</h2><h3 id="初级的git命令">初级的git命令</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>git init</strong>：<strong>初始化</strong>本地仓库（创建新仓库）</p></li><li class="lvl-2"><p><strong>git clone</strong>：拷贝一份远程仓库，也就是<strong>下载一个项目</strong>。</p></li><li class="lvl-2"><p><strong>git status</strong>：查看仓库<strong>当前的状态</strong>，显示有变更的文件。</p></li><li class="lvl-2"><p><strong>git add</strong>：添加文件到暂存区（缓存区）</p></li><li class="lvl-2"><p><strong>git commit</strong>：提交暂存区到本地仓库。</p></li><li class="lvl-2"><p><strong>git push</strong>：上传本地仓库到远程仓库并合并。</p></li><li class="lvl-2"><p><strong>git pull</strong>：下载远程仓库到本地仓库并合并。</p></li><li class="lvl-2"><p><strong>git branch</strong>：显示本地分支或创建新<strong>分支。</strong></p></li><li class="lvl-2"><p><strong>git checkout</strong>：切换分支或检出文件。</p></li><li class="lvl-2"><p><strong>git merge</strong>：合并分支。</p></li><li class="lvl-2"><p><strong>git log</strong>：查看提交日志。</p></li><li class="lvl-2"><p><strong>git diff</strong>：比较文件的不同。</p></li><li class="lvl-2"><p><strong>git reset</strong>：回退版本。</p></li><li class="lvl-2"><p><strong>git rm</strong>：删除文件。</p></li><li class="lvl-2"><p><strong>git mv</strong>：移动或重命名文件。</p><hr></li></ul><h3 id="下载文件">下载文件</h3><h4 id="git-pull-与-git-clone辨析">git pull 与 git clone辨析</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>git clone</strong>是在本地没有仓库的时候，从远程仓库克隆整个仓库到本地，包括所有的分支、标签、提交历史等。它是一个从无到有的过程，不需要先初始化本地仓库。例如，你可以使用以下命令克隆一个远程仓库到本地：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tensorflow/tensorflow.git</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>git pull</strong>是在本地有仓库的情况下，从远程仓库获取最新的版本，并与本地分支合并。它相当于先执行<code>git fetch</code>，然后再执行<code>git merge</code>。例如，你可以使用以下命令拉取远程master分支的最新版本，并与本地master分支合并：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>git clone</strong>和<strong>git pull</strong>的主要区别是：<strong>git clone</strong>只需要执行一次，就可以在本地创建一个完整的远程仓库的副本；而<strong>git pull</strong>需要在本地已经存在一个远程仓库的副本的基础上，定期执行，以保持本地和远程的同步。</p></li></ul><h4 id="gitclone-使用时的注意事项">gitclone 使用时的注意事项</h4><ul class="lvl-0"><li class="lvl-2"><p>git clone默认是克隆远程仓库的master分支，也就是HEAD指向的分支。如果你想确定下载下来的是哪一个分支，你可以使用以下命令查看：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>这个命令会显示本地和远程的所有分支，你可以看到当前分支有一个星号（*）标记，通常是master分支。你也可以看到远程仓库的其他分支，它们的前缀是<code>remotes/origin/</code>。</p><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">如果运行时你的<code>git bash</code>显示的是</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br></pre></td></tr></table></figure><p>那就说明你<strong>还没有进入到</strong>克隆的仓库的文件夹中，建议返回文件夹看看（别老盯着你那破小黑屏啦）</p><ul class="lvl-0"><li class="lvl-2"><p>如果你想克隆远程仓库的其他分支，而不是默认的master分支，你可以使用以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branchname&gt; &lt;remote-repo-url&gt;</span><br></pre></td></tr></table></figure><p>这个命令会克隆指定的分支，并自动切换到该分支。例如，你可以使用以下命令克隆远程仓库的dev分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/tensorflow/tensorflow.git</span><br></pre></td></tr></table></figure><hr><h3 id="分支操作">分支操作</h3><h4 id="git-branch–单分支操作">git branch–单分支操作</h4><p>git branch是对于分支的操作的一个命令。它有很多常用的操作，例如：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>git branch</strong>：不带参数时，可以列出<strong>本地的所有</strong>分支，当前分支有一个星号（*）标记¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -a</strong>：可以列出<strong>本地和远程</strong>的所有分支，远程分支的前缀是<code>remotes/origin/</code>²³。</p></li><li class="lvl-2"><p><strong>git branch &lt;分支名&gt;</strong>：可以<strong>创建</strong>一个新的分支，基于当前分支的最新提交¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -d &lt;分支名&gt;</strong>：可以<strong>删除</strong>一个本地分支，前提是该分支已经被合并到其他分支¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -D &lt;分支名&gt;</strong>：可以<em>强制删除</em>一个本地分支，即使该分支没有被合并到其他分支¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -m &lt;原分支名&gt; &lt;新分支名&gt;</strong>：可以<strong>重命名</strong>一个本地分支，如果新分支名已经存在，会报错¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -M &lt;原分支名&gt; &lt;新分支名&gt;</strong>：可以<em>强制重命名</em>一个本地分支，如果新分支名已经存在，会覆盖它¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch --set-upstream-to=origin/&lt;远程分支名&gt; &lt;本地分支名&gt;</strong>：可以设置本地分支和远程分支的关联关系，方便执行pull和push操作³⁵。</p></li></ul><p>举例说明：</p><ul class="lvl-0"><li class="lvl-2"><p>假设我们要在本地<strong>创建一个叫做dev的新分支，并切换到该分支</strong>，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>或者使用快捷方式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要删除dev这个本地分支，并且它已经被合并到master分支，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev这个本地分支重命名为feature，并且覆盖掉已经存在的feature分支，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -M dev feature</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要设置feature这个本地分支和origin/feature这个远程分支的关联关系，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git branch --set-upstream-to=origin/feature</span><br></pre></td></tr></table></figure><h4 id="多分支操作–分支合并">多分支操作–分支合并</h4><p>分支合并是指将两个或多个不同的分支的代码合并到一起，形成一个新的分支或更新一个已有的分支¹²。分支合并可以让我们在不同的开发环境中做事，并来回切换，也可以让我们将不同的功能或修复合并到主线上¹。</p><p>实现分支合并的主要命令是<strong>git merge</strong>，它可以将任何分支合并到当前分支中去¹²⁴。例如，如果我们要将dev分支合并到master分支，我们可以执行以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>这样就会在master分支上创建一个新的提交节点，记录这次合并的结果¹²⁴。</p><p>进行分支合并的时候，需要注意以下几点：</p><ul class="lvl-0"><li class="lvl-2"><p>分支合并可能会产生<strong>冲突</strong>，即两个分支对同一个文件的同一个地方做了不同的修改¹²⁴。这时候，git无法自动完成合并，需要我们手动解决冲突，并重新提交¹²⁴。</p></li><li class="lvl-2"><p>分支合并有不同的<strong>策略</strong>，例如fast-forward、recursive、ours、theirs等¹³。不同的策略会影响合并的结果和历史记录¹³。默认情况下，git会自动选择合适的策略，但我们也可以用**-s**选项来指定策略¹³。</p></li><li class="lvl-2"><p>分支合并之前，最好先更新本地和远程的代码，以保证代码是最新的²。我们可以用<strong>git pull</strong>命令来拉取远程仓库的代码，并自动合并到本地分支²⁴。</p></li></ul><h4 id="git-merge与git-checkout-其他用法的解析">git merge与git checkout 其他用法的解析</h4><p>git merge 和 git checkout 这两个命令除了用于分支合并和切换之外，还有一些其他的功能：</p><p><strong>git merge</strong>的其他功能：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>git merge --abort</strong>：可以取消正在进行的合并操作，恢复到合并之前的状态¹²。这个命令在遇到合并冲突时很有用，可以让你重新选择合并策略或者放弃合并¹²。</p></li><li class="lvl-2"><p><strong>git merge --squash</strong>：可以将目标分支的多个提交压缩成一个提交，然后合并到当前分支¹²。这个命令可以让你保持提交历史的简洁，避免过多的合并提交¹²。</p></li><li class="lvl-2"><p><strong>git merge --continue</strong>：可以在解决完合并冲突后，继续完成合并操作¹²。这个命令相当于执行了git add和git commit两个命令¹²。</p></li></ul><p>举例说明：</p><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev分支合并到master分支，但是发生了冲突，我们可以执行以下命令来取消合并：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev分支合并到master分支，但是dev分支有很多小的提交，我们可以执行以下命令来压缩成一个提交：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --squash dev</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev分支合并到master分支，发生了冲突，我们手动解决了冲突，我们可以执行以下命令来继续合并：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p><strong>git checkout</strong>的其他功能：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>git checkout &lt;文件名&gt;</strong>：可以将指定文件恢复到上一次提交的状态³ 。这个命令在你修改了文件但是不想保留修改时很有用³ 。</p></li><li class="lvl-2"><p><strong>git checkout <commit> &lt;文件名&gt;</commit></strong>：可以将指定文件恢复到指定提交的状态³ 。这个命令在你想回退某个文件到某个版本时很有用³ 。</p></li><li class="lvl-2"><p><strong>git checkout -b &lt;新分支名&gt;</strong>：可以<strong>创建一个新的分支，并切换到该分支</strong>³ 。这个命令相当于执行了git branch和git checkout两个命令³ 。</p></li></ul><p>举例说明：</p><ul class="lvl-0"><li class="lvl-2"><p>假设我们修改了index.html文件，但是不想保留修改，我们可以执行以下命令来恢复文件：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout index.html</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们想将index.html文件恢复到a123456这个提交的状态，我们可以执行以下命令来恢复文件：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout a123456 index.html</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们想创建一个新的分支feature，并切换到该分支，我们可以执行以下命令来创建和切换分支：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br></pre></td></tr></table></figure><h2 id="清空本地的Git关联的远程仓库（删库跑路本地版）">清空本地的Git关联的远程仓库（删库跑路本地版）</h2><ul class="lvl-0"><li class="lvl-2"><p>如果您想要删除本地仓库的所有文件、分支和提交，但<strong>保留</strong>远程仓库的链接，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要删除本地仓库的所有文件、分支和提交，并且<strong>断开</strong>远程仓库的链接，您可以直接删除本地仓库的目录，或者在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf *</span><br><span class="line"><span class="built_in">rm</span> -rf .git</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要保留本地仓库的部分文件、分支和提交，但重置到远程仓库的状态，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要清除本地仓库中未被Git跟踪的文件，如包、配置、日志等，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git clean -d --force</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要删除本地仓库关联的远程仓库，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;针对本地仓库的操作&quot;&gt;针对本地仓库的操作&lt;/h2&gt;
&lt;h3 id=&quot;初级的git命令&quot;&gt;初级的git命令&lt;/h3&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;git init&lt;/strong&gt;：&lt;strong</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="git" scheme="https://elementgc.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://elementgc.github.io/2023/05/23/hello-world/"/>
    <id>https://elementgc.github.io/2023/05/23/hello-world/</id>
    <published>2023-05-23T12:12:58.294Z</published>
    <updated>2023-05-26T07:56:35.573Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
