<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心有所向，日复一日，必有精进</title>
  
  <subtitle>欢迎来到ELement_GC的咸鱼博客</subtitle>
  <link href="https://elementgc.github.io/atom.xml" rel="self"/>
  
  <link href="https://elementgc.github.io/"/>
  <updated>2023-06-06T11:11:58.426Z</updated>
  <id>https://elementgc.github.io/</id>
  
  <author>
    <name>Element_GC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库学习笔记（10）—— 第一、第二、第三范式与BC范式</title>
    <link href="https://elementgc.github.io/2023/06/06/data-base-note-10/"/>
    <id>https://elementgc.github.io/2023/06/06/data-base-note-10/</id>
    <published>2023-06-06T03:18:48.000Z</published>
    <updated>2023-06-06T11:11:58.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="范式">范式</h2><ul class="lvl-0"><li class="lvl-2">范式（Normal Forma，NF），是一种关系的状态，也是衡量关系模式好坏的标准</li><li class="lvl-2">范式的种类与数据依赖存在直接凉席<strong>关系模式中存在函数依赖就可能存在数据冗余，引发数据操作问题</strong></li><li class="lvl-2">范式可以确保数据库模式中没有各种类型的异常和不一致性，确定关系模式是否符合凡是要求，看的是<strong>属性之间的函数依赖</strong>，与属性的具体值无关</li><li class="lvl-2">一个规范化的模式，要求除了<strong>与其他关系模式进行连接的外键</strong>之外，数据库中其他数据都不能被复制</li><li class="lvl-2">规范化的目的是<ul class="lvl-2"><li class="lvl-4">让关系模式满足特定约束</li><li class="lvl-4">避免不必要的数据重复</li></ul></li></ul><h2 id="第一范式">第一范式</h2><p>同<a href="/2023/06/04/data-base-note-7/#第一范式">“第一范式”</a>中的内容，只要是能够进入数据库的关系模式，都一定满足第一范式</p><ul class="lvl-0"><li class="lvl-2"><p>满足第一范式的关系成为<strong>规范化关系</strong>，否则成为非规范化的关系</p></li><li class="lvl-2"><p>关系数据库研究的关系都是<strong>规范化的关系</strong></p></li></ul><h2 id="第二范式">第二范式</h2><p>对第一范式中的关系模式进行分解，排除其中的<strong>非主属性对主属性的部分函数依赖</strong>，分解后的关系模式就能成为第二范式，即第二范式就是<strong>不存在部分函数依赖的关系模式</strong>，详情见<a href="/2023/06/04/data-base-note-7/#第二范式">“第二范式”</a></p><ul class="lvl-0"><li class="lvl-2"><p>只有<strong>主键是复合属性</strong>的时候，关系模式才可能存在部分函数依赖，导致其不满足第二范式</p></li><li class="lvl-2"><p>第二范式仅仅消除了第一范式的部分问题<strong>仍然可能存在数据冗余和操作异常</strong></p></li><li class="lvl-2"><p>对于不满足第二范式的关系模式，可以通过<a href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95">这种算法</a>进行分解</p></li></ul><h2 id="第三范式">第三范式</h2><p>如果关系模式<strong>已经是第二范式</strong>，且每个非主属性都<strong>不传递依赖于主属性</strong>，则称该关系模式满足第三范式</p><ul class="lvl-0"><li class="lvl-2"><p>第三范式中，关系模式是由主属性（主键）和一组<strong>相互独立</strong>的非主属性组成的</p></li><li class="lvl-2"><p>非主属性相互独立，单独直接依赖与主键</p></li><li class="lvl-2"><p>对于将第二范式分解为第三范式，并保持<strong>函数依赖性</strong>，可以通过<a href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95">第三范式分解算法</a> 来实现</p></li><li class="lvl-2"><p>若要同时保持其无损连接性和函数依赖性，可以通过 <a href="#%E4%BF%9D%E6%8C%81%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%92%8C%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E7%9A%843NF%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95">保持函数依赖和无损连接的3NF分解算法</a> 来实现</p></li></ul><h2 id="BC范式">BC范式</h2><h2 id="算法说明">算法说明</h2><h3 id="第二范式分解算法">第二范式分解算法</h3><p>这一部分内容来自于教材P152，算法4.5，若有问题请以书上为准</p><ul class="lvl-0"><li class="lvl-2"><p>设有关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>R</mi><mo>∈</mo><mn>1</mn><mi>N</mi><mi>F</mi><mo separator="true">,</mo><mi>R</mi><mo mathvariant="normal">∉</mo><mn>2</mn><mi>N</mi><mi>F</mi><mo separator="true">,</mo><msub><mi>X</mi><mn>1</mn></msub><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">R(X,Y,Z),R\in 1NF,R\notin 2NF,X_1\subseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> ，其中， X 是<strong>主属性</strong>，Y 和 Z 都是非主属性，且关系模式 R 满足函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo><mover><mo><mo>⟶</mo></mo><mi>f</mi></mover></mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo><mover><mo><mo>⟶</mo></mo><mi>P</mi></mover></mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X_1\stackrel{f}{\longrightarrow} Y,X\stackrel{P}{\longrightarrow} Y,X\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4942em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3442em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7581em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4838em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p></li><li class="lvl-2"><p>将关系模式 R 进行分解，得到新的关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_1(X_1,Y),R_2(X,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> ，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>:</mo><msub><mi>X</mi><mn>1</mn></msub><mo><mover><mo><mo>⟶</mo></mo><mi>f</mi></mover></mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R_1:X_1\stackrel{f}{\longrightarrow} Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4942em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3442em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7581em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 一定满足第二范式</p></li><li class="lvl-2"><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_2(X,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> ，如果不满足第二范式，则重复上面步骤，知道分解出的所有结果都满足第二范式为止</p></li><li class="lvl-2"><p>由<a href="/2023/06/05/data-base-note-9/#两个分解结果的无损连接判断">“无损连接的二分判断”</a>可知，这样分解出来的结果为无损连接，R 的分解具有无损连接性</p></li></ul><h3 id="第三范式分解算法">第三范式分解算法</h3><p>这一部分内容来自于教材P153，算法4.6，若有问题请以书上为准</p><ul class="lvl-0"><li class="lvl-2"><p>输入：关系模式 R 和 R 的最小依赖集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li class="lvl-2"><p>处理：</p><ol><li class="lvl-5">若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中存在函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X\rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> ，且 XA = R ，则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\rho={R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span> ，转 4；</li><li class="lvl-5">若 R 中某些属性与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中所有函数依赖的左部、右部<strong>都无关</strong>，则将这些属性<strong>单独构成一个关系模式</strong>，从 R 中分出；</li><li class="lvl-5">对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中所有的函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X\rightarrow A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，都将其作为一个<strong>单独的关系模式</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">XA_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。对于多个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>X</mi><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>X</mi><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">XA_1,XA_2,...,XA_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，可以用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msub><mi>A</mi><mn>1</mn></msub><msub><mi>A</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">XA_1A_2...A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 取代，但是注意<strong>左部必须完全相等才能合并</strong></li><li class="lvl-5">将所有的关系模式组合成集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> ，输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span></li></ol></li><li class="lvl-2"><p>输出：R 的一个保持函数依赖的分解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho=\{R_1,R_2...\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mclose">}</span></span></span></span> ，每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都是一个第三范式</p></li></ul><h3 id="保持函数依赖和无损连接的3NF分解算法">保持函数依赖和无损连接的3NF分解算法</h3><p>这一部分内容来自于教材P153，算法4.7，若有问题请以书上为准</p><ul class="lvl-0"><li class="lvl-2"><p>输入：经过<strong>保持函数依赖的第三范式分解算法</strong>得到的结果</p></li><li class="lvl-2"><p>处理：</p><ol><li class="lvl-5">使用<strong>追逐法</strong>或者其他办法判断这几个是不是无损分解，若是，转3</li><li class="lvl-5">令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mi>ρ</mi><mo>∪</mo><mi>X</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho=\rho\cup X=\{R_1,R_2,...,X\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.75em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">}</span></span></span></span> ，其中 X 是原关系模式 R 的<strong>候选码</strong></li><li class="lvl-5">输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span></li></ol></li><li class="lvl-2"><p>输出：R 的一个保持函数依赖的分解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho=\{R_1,R_2...\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mclose">}</span></span></span></span> ，每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 都是一个第三范式，且保证了无损连接性</p></li></ul><h3 id="BDNF分解算法">BDNF分解算法</h3><p>这一部分内容来自于教材P157，算法4.8，若有问题请以书上为准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;范式&quot;&gt;范式&lt;/h2&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;范式（Normal Forma，NF），是一种关系的状态，也是衡量关系模式好坏的标准&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;范式的种类与数据依赖存在直接凉席&lt;</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="规范化" scheme="https://elementgc.github.io/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    <category term="范式" scheme="https://elementgc.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（9）--Armstrong公理和模式分解</title>
    <link href="https://elementgc.github.io/2023/06/05/data-base-note-9/"/>
    <id>https://elementgc.github.io/2023/06/05/data-base-note-9/</id>
    <published>2023-06-05T04:53:17.000Z</published>
    <updated>2023-06-07T13:10:27.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Armstrong公理">Armstrong公理</h2><h3 id="函数依赖中需要解决的问题">函数依赖中需要解决的问题</h3><p><strong>如何从一些已知的函数依赖去判断另外一些函数依赖是否成立</strong>？</p><p>如果在某个关系模式中存在 A—&gt;B  B—&gt;C，记为 F = {A–&gt;B, B–&gt;C} ，那么在该关系中是否成立 A–&gt; C 这个问题称为逻辑蕴涵问题。若 A–&gt; C 成立，则称 F 逻辑蕴涵  A–&gt; C ，记做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊨</mo><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F\models A\rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.999em;vertical-align:-0.249em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p><p>一个关系模式可以通过<strong>多个函数依赖形成一个函数依赖集</strong>。现在有一个新的函数依赖不属于这个函数依赖集，而是<strong>从集合中根据一定的规则推导出来</strong>，就可以说这个函数依赖集<strong>逻辑蕴涵</strong>这个新的函数依赖；例如：</p><ul class="lvl-0"><li class="lvl-2"><p>在关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span> 中，我们得到一个函数依赖集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo>→</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X\rightarrow Y\rightarrow Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span>，而根据传递依赖，我们可以推导出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>，这个函数依赖是原本的函数依赖集没有的，我们可以表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo>→</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>⊨</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">(X\rightarrow Y\rightarrow Z)\models X\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p></li><li class="lvl-2"><p>如果一个函数依赖<strong>能够</strong>通过集合中的其他函数推导出，则该函数依赖是<strong>多余的</strong>。</p></li></ul><h3 id="闭包">闭包</h3><p>函数依赖集 F 所<strong>逻辑蕴含的函数依赖全体</strong>称为 F 的闭包（Closure），记为F<sup>+</sup>, 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo>∣</mo><mi>F</mi><mo>⊨</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F^+=\{X\rightarrow Y\mid F\models X\rightarrow Y\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.999em;vertical-align:-0.249em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span></span></span></span></p><ul class="lvl-0"><li class="lvl-2"><p>函数依赖集的<strong>闭包</strong>，也可以称为<strong>完备集</strong>，定义了通过给定函数依赖集<strong>所能推导出的所有函数依赖</strong></p></li><li class="lvl-2"><p>通过 F 得到 F<sup>+</sup> 的算法可以通过哦<strong>Armstrong公理</strong> 推导出来</p></li><li class="lvl-2"><p><strong>无冗余</strong>的<strong>函数依赖集</strong>及其<strong>完备集</strong>是好的关系涉及</p></li><li class="lvl-2"><p>根据已知的函数依赖集，推导出其他函数依赖时所依据的规则称为<strong>推理规则</strong></p></li><li class="lvl-2"><p>函数依赖的<strong>推理规则</strong>最早出现在<strong>Armstrong的论文里</strong>，也被称为<strong>Armstrong公理</strong></p></li></ul><h4 id="闭包的求解">闭包的求解</h4><p>除了上述的函数依赖集闭包之外，还有一个常用的闭包叫做<strong>属性集闭包</strong>，求解这两种闭包是题目中常见的也是基础的题型，这里来简要介绍一下：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>函数依赖集闭包求解：</strong></p><p>函数依赖集的闭包 F<sup>+</sup> 是在函数<strong>所有可能的依赖</strong>的基础上，减去所提供的函数依赖、再减去不能从提供的函数依赖推导出来的可能的函数依赖，最终还剩余的函数依赖，<strong>以关系模式R({X,Y}，{X-&gt;Y})为例</strong>，主要的求解步骤如下：</p><ol><li class="lvl-5"><p>计算出所有可能的函数依赖数量：2<sup>n</sup> * 2<sup>n</sup> ，其中，n表示该关系模式中的属性个数，这里取 n = 2，可能的函数依赖有4*4=16个</p></li><li class="lvl-5"><p>减去提供的函数依赖一个，剩余 16-1=15 个</p></li><li class="lvl-5"><p>减去空集对其余属性集的依赖，共 2<sup>n</sup> – 1 个，此处为3个，剩余 15 - 3 = 12 个</p></li><li class="lvl-5"><p>减去无法推导出来的依赖，如 Y—&gt;X，Y—&gt;XY，此处为2个，剩余 12 - 2 = 10 个</p></li><li class="lvl-5"><p>最终结果：函数依赖集 F 的闭包 F<sup>+</sup> 共有10个，分别为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right left" columnspacing="0em 1em 0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>X</mi><mo>→</mo><mi>X</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>X</mi><mo>→</mo><mi>X</mi><mi>Y</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>X</mi><mo>→</mo><mi mathvariant="normal">∅</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>Y</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>Y</mi><mo>→</mo><mi mathvariant="normal">∅</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>X</mi><mi>Y</mi><mo>→</mo><mi>X</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>X</mi><mi>Y</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>X</mi><mi>Y</mi><mo>→</mo><mi>X</mi><mi>Y</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>X</mi><mi>Y</mi><mo>→</mo><mi mathvariant="normal">∅</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∅</mi><mo>→</mo><mi mathvariant="normal">∅</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}X\rightarrow X,&amp;&amp;X\rightarrow XY,&amp;X\rightarrow \empty\\Y\rightarrow Y,&amp;&amp;&amp;Y\rightarrow \empty\\XY\rightarrow X,&amp;XY\rightarrow Y,&amp;XY\rightarrow XY,&amp;XY\rightarrow \empty\\&amp;&amp;&amp;\empty\rightarrow\empty\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∅</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∅</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∅</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">∅</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∅</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol></li><li class="lvl-2"><p><strong>属性集闭包求解：</strong></p><p>通过上面的步骤可以看出，其实求解函数依赖集的闭包步骤很麻烦，而且还是使用的排除法，当关系模型复杂是很难适用，故人们为了尽快确定函数依赖 X—&gt;Y 是否成立，<strong>将函数依赖集的闭包 F<sup>+</sup> 的计算简化成对属性组 X 的闭包 X<sup>+</sup> 的计算</strong>，求解属性集 X 相对于函数依赖集 F 的闭包步骤如下：</p><ol><li class="lvl-5"><p>将X加入到X<sup>+</sup>中</p></li><li class="lvl-5"><p>对于目前X<sup>+</sup>中的每一个属性A，找出能够通过 F 推导出的X<sup>+</sup> 以外的属性，将它们加入到X+中</p></li><li class="lvl-5"><p>重复执行步骤2，找出所有能够通过函数依赖规则推导出的新属性，将它们加入到X+中，直到不再有新的属性加入</p></li><li class="lvl-5"><p>返回得到的X<sup>+</sup>，它就是X的闭包</p></li></ol><p>书上有提供这一过程的具体算法，<a href="#%E5%B1%9E%E6%80%A7%E9%9B%86%E9%97%AD%E5%8C%85%E7%AE%97%E6%B3%95">点击此处查看</a></p></li></ul><h3 id="Armstrong公理的主要规则">Armstrong公理的主要规则</h3><h4 id="自反性">自反性</h4><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>X</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Y\subseteq X\subseteq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> ，则我们能得出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> ，即<strong>平凡函数依赖</strong></p><h4 id="增广性">增广性</h4><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 成立，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Z\subseteq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> ，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Z</mi><mo>→</mo><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XZ\rightarrow YZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">XZ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> ，其中 <strong>XZ 和 YZ 是对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⋃</mo><mi>Z</mi><mo separator="true">,</mo><mi>Y</mi><mo>⋃</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\bigcup Z,Y\bigcup Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋃</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋃</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 的简写</strong></p><h4 id="传递性">传递性</h4><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y,Y\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 成立，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 必然成立</p><h4 id="其他扩展规则">其他扩展规则</h4><ul class="lvl-0"><li class="lvl-2"><p>合并性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>Z</mi><mo stretchy="false">}</mo><mo>⊨</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">\{X\rightarrow Y,X\rightarrow Z\}\models X\rightarrow YZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p></li><li class="lvl-2"><p>伪传递性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>W</mi><mi>Y</mi><mo>→</mo><mi>Z</mi><mo stretchy="false">}</mo><mo>⊨</mo><mi>X</mi><mi>W</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">\{X\rightarrow Y,WY\rightarrow Z\}\models XW\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">WY</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p></li><li class="lvl-2"><p>分解性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo>⊆</mo><mi>Y</mi><mo stretchy="false">}</mo><mo>⊨</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">\{X\rightarrow Y,Z\subseteq Y\}\models X\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p></li><li class="lvl-2"><p>复合性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>W</mi><mo>→</mo><mi>Z</mi><mo stretchy="false">}</mo><mo>⊨</mo><mi>X</mi><mi>W</mi><mo>→</mo><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">\{X\rightarrow Y,W\rightarrow Z\}\models XW\rightarrow YZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p></li><li class="lvl-2"><p>通用一致性*：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>W</mi><mo>→</mo><mi>Z</mi><mo stretchy="false">}</mo><mo>⊨</mo><mi>X</mi><mo>⋃</mo><mo stretchy="false">(</mo><mi>W</mi><mo>−</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">\{X\rightarrow Y,W\rightarrow Z\}\models X\bigcup (W-Z)\rightarrow YZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊨</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⋃</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p><ul class="lvl-2"><li class="lvl-4">这个甚至书上都没有介绍</li></ul></li></ul><h3 id="Armstrong公理的性质">Armstrong公理的性质</h3><ul class="lvl-0"><li class="lvl-2"><p>正确性：Armstrong公理是正确的，如果 X—&gt;Y 是通过推理规则从原本的F中推理得来的，那 <strong>X—&gt;Y 必然是在 F<sup>+</sup> 中的</strong></p></li><li class="lvl-2"><p>完备性：F<sup>+</sup> 中的函数依赖必定能够<strong>通过推理规则从 F 中推出</strong></p></li><li class="lvl-2"><p>公理的正确性和有效性保证了推导的有效性和完整性</p></li></ul><h3 id="函数依赖确定的使用">函数依赖确定的使用</h3><h4 id="确定候选码与主码">确定候选码与主码</h4><ul class="lvl-0"><li class="lvl-2"><p>设 K 为关系模式 <em>R(U,F)</em> 中的属性或属性集，若能得出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo><mover><mo><mo>⟶</mo></mo><mi>F</mi></mover></mo><mi>U</mi></mrow><annotation encoding="application/x-tex">K\stackrel{F}{\longrightarrow}U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> ，即能够通过 K 让其完全函数决定其他属性，就让 K 称为该关系模式的候选码，K 中的属性就称为主属性</p></li><li class="lvl-2"><p><strong>全码</strong>意味着这个关系模式里面的属性都是主属性，这个时候任意属性集的真子集都不能决定其他的任意属性，也就是说<strong>就只存在平凡依赖，只存在自反律</strong></p></li><li class="lvl-2"><p>由于候选码可以决定一个元组，那就可以得到<strong>候选码可以决定关系模式中的任意一个属性</strong></p></li><li class="lvl-2"><p>对于通过函数依赖集求解候选码的方法，教材上有详细介绍，<a href="#%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E5%80%99%E9%80%89%E7%A0%81%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95">点击此处查看</a></p></li></ul><h4 id="确定外码">确定外码</h4><ul class="lvl-0"><li class="lvl-2"><p>外码：即在R1中不是主码，在R2中作为主码的属性，在R1中称为<strong>R1的外码</strong></p></li><li class="lvl-2"><p>确定外码，首先得确定两个关系模式的候选码</p></li><li class="lvl-2"><p>一个关系模式的外码不能是自己的主码，但可以作为主码的一部分，作为主属性存在</p></li></ul><h4 id="最小函数依赖集">最小函数依赖集</h4><ul class="lvl-0"><li class="lvl-2"><p>有时候给出的函数依赖集并不是<strong>最简</strong>的，这有时会拖累我们对关系的后续处理，例如关系的分解、判断是否为无损分解等。所以，我们在必要时，需要对函数依赖集进行化简。</p></li><li class="lvl-2"><p>最小函数依赖集 F_min 有如下几个要点：</p><ul class="lvl-2"><li class="lvl-4">F_min 中的任意函数依赖<strong>右部</strong>仅有一个属性</li><li class="lvl-4">F_min 中不存在那种删了之后不影响依赖传递的，冗余函数依赖，即没有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo separator="true">,</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo separator="true">,</mo><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\rightarrow B,B\rightarrow C,A\rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> ，在这种情况下函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 就是冗余的</li><li class="lvl-4">F_min 中的函数依赖左边不存在冗余属性，即没有那种 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>→</mo><mi>C</mi><mo separator="true">,</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">AB\rightarrow C,B\rightarrow C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> ，这样的话 A 就算是属性冗余，如果有那种 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>→</mo><mi>A</mi><mo separator="true">,</mo><mi>A</mi><mo>→</mo><mi>C</mi><mo separator="true">,</mo><mi>A</mi><mi>C</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C\rightarrow A,A\rightarrow C,AC\rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的情况，那也说明 A 和 C 中的其中一个是冗余的，需要做的是剔除掉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>C</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">AC\rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 里面的 A 或者 C 就行</li></ul></li><li class="lvl-2"><p>对于最小函数依赖集的求解，我们可以通过参考书上的步骤进行，<a href="#%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95">点击此处查看</a></p></li></ul><h2 id="模式分解">模式分解</h2><ul class="lvl-0"><li class="lvl-2"><p>模式分解就是将关系模式进行细分化，将数据转换为范式的格式以避免数据冗余</p></li><li class="lvl-2"><p>关系模式R的分解就是用两个或以上的新关系模式来替代原本的关系模式，分解后的属性集都是R中的子集，其并集与R的属性集相同</p></li><li class="lvl-2"><p>通过模式分解，可以消除不良设计中的一些问题，如冗余、不一致、异常等</p></li></ul><h3 id="模式分解问题">模式分解问题</h3><p>对于关系模式R(U)，我们可以将其看做一个属性的集合，称为泛关系模式。将 R 的子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_1,R_2,...,R_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的集合用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>R</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho=\{R_1,R_2,...,R_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 表示。R 的当前值用 r 表示，称为泛关系；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 的当前值用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mo>&lt;</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>r</mi><mi>n</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">\sigma=&lt;r_1,r_2,...,r_n&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 表示。</p><p>但当我们进行模式分解的时候，就会遇到下面两个问题：<em><s>（这里看不懂没关系，后面有详细解释）</s></em></p><ul class="lvl-0"><li class="lvl-2"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 是否等价，即是否表示相同的数据。对于这个问题，我们用**“无损连接”**特性表示</p></li><li class="lvl-2"><p>泛关系模式中的 R 存在函数依赖集 F ，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 的每个关系模式上也有函数依赖集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>F</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{F_1,F_2,...,F_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> ，两者之间是否等价？这个问题我们用**“保持依赖”**特性表示</p></li></ul><h3 id="无损连接分解">无损连接分解</h3><p>一个关系表被分成两个或两个以上的小表后，通过<strong>连接</strong>被分出来的小表<strong>可以获得原始表的内容</strong>，我们称这种分解为<strong>无损连接分解</strong>，否则就是<strong>有损分解</strong></p><p>举个例子:</p><p><img src="https://elementgc.github.io/2023/06/05/data-base-note-9/p1.png" alt="无损分解举例" width="350" height="300"></p><p>通过这个例子我们能够看到，分解是否具有无损性主要还是以<strong>函数依赖有关</strong></p><p><em><s>（个人理解）</s></em>：若是想对第二个表进行无损分解，可以分解为 r1(B,C) 和 r2(C,A) 两组</p><h4 id="无损连接分解验证方法——追逐法">无损连接分解验证方法——追逐法</h4><p>无损连接的验证方法在这里先用文字口头描述一遍：</p><ol><li class="lvl-3"><p>获取原关系模式 R 和函数依赖集 F，分解后的关系集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> ；</p></li><li class="lvl-3"><p>属性集合和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 构造成一个二维图表，顶部表头为各个属性，左侧表头为分解后的关系</p></li><li class="lvl-3"><p>根据分解后的关系，在图表中进行标记，若存在对应的属性，则标记 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mtext>列号</mtext></msub></mrow><annotation encoding="application/x-tex">a_{列号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">列号</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，否则保持为空（书上说的是标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mtext>行号列号</mtext></msub></mrow><annotation encoding="application/x-tex">b_{行号列号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">行号列号</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，不过我觉得用处不大，怎么方便怎么来）</p></li><li class="lvl-4"><p>用 F 中的函数依赖一个一个进行对照，对于A —&gt;B，如果某一行的 A 对应的值不为空，则这一行的 B 所在的列也不留空，填上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mtext>列号</mtext></msub></mrow><annotation encoding="application/x-tex">a_{列号}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">列号</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li class="lvl-3"><p>重复对照每一个函数依赖，直到全部对照完</p><ul class="lvl-2"><li class="lvl-5">若是有哪一行的<strong>每一列都不为空</strong>，就说明这样的分解是无损连接分解，<strong>只要有一行就行</strong></li></ul></li></ol><p>具体的算法方式如下见<a href="#%E8%BF%BD%E9%80%90%E6%B3%95%E7%AE%97%E6%B3%95">算法集合-追逐法算法</a></p><h4 id="两个分解结果的无损连接判断">两个分解结果的无损连接判断</h4><p>当关系模式的分解只分解出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho=\{R_1,R_2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 两个关系模式时，我们可以通过以下公式快速判断是否为无损连接分解：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>−</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mtext>或</mtext><mo stretchy="false">(</mo><msub><mi>R</mi><mn>2</mn></msub><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_1 \cap R_2)\rightarrow(R_1-R_2)或(R_2-R_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>即分解出的两个关系模式的<strong>公共属性</strong>能够决定这两个关系的<strong>非公共属性</strong>时，即可证明这样的分解模式是无损连接分解</p><h3 id="保持依赖分解">保持依赖分解</h3><p>简单来讲，保持依赖分解就是保证在模式分解之后，原关系模式的函数依赖仍然能够对分解后的关系模式适用，而不存在<strong>分解后的</strong>关系模式集合中<strong>无法推导出</strong>原本关系模式的函数依赖集 <strong>F 所拥有的函数依赖</strong>的情况</p><p>保持依赖分解的原则：</p><ul class="lvl-0"><li class="lvl-2"><p>分解后的所有关系模式的函数依赖互相结合，要能够凑出原函数依赖集合 F 中的所有依赖</p></li><li class="lvl-2"><p>分解后的所有关系模式的函数依赖互相结合，不能推导出不存在于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∪</mo><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F\cup F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> 的函数依赖，即不能推导出原本函数依赖集得不到的函数依赖</p></li></ul><h3 id="模式分解综合例题">模式分解综合例题</h3><p>设有关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>D</mi><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(SNo,Dept,DP)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span> ，分别表示学生的学号、专业以及办公室地点，函数依赖集为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>D</mi><mi>P</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{SNo\rightarrow Dept,Dept\rightarrow DP\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">}</span></span></span></span> ，现将 R 分解为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>D</mi><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho = \{R_1(SNo,Dept),R_2(SNo,DP)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)}</span></span></span></span>  ，判断分解结果的<strong>无损连接性</strong>和<strong>保持函数依赖性</strong>：</p><ol><li class="lvl-3"><p>无损连接性判断：</p><p>将原本的关系模式分解成了两个关系模式，可以通过公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>−</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mtext>或</mtext><mo stretchy="false">(</mo><msub><mi>R</mi><mn>2</mn></msub><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_1 \cap R_2)\rightarrow(R_1-R_2)或(R_2-R_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 来判断其无损连接性：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>R</mi><mn>2</mn></msub><mo>=</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><msub><mi>R</mi><mn>1</mn></msub><mo>−</mo><msub><mi>R</mi><mn>2</mn></msub><mo>=</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">R_1\cap R_2=SNo,R_1-R_2=Dept</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span></span></span></span> ，已知 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">SNo\rightarrow Dept</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span></span></span></span> ，故 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>−</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_1 \cap R_2)\rightarrow(R_1-R_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 成立，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>D</mi><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho = \{R_1(SNo,Dept),R_2(SNo,DP)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)}</span></span></span></span> 是无损分解</p></li><li class="lvl-3"><p>保持函数依赖性判断</p><p>通过原本的函数依赖 F 可知，R1 与 R2 的函数依赖分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">SNo\rightarrow Dept</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">SNo\rightarrow DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> ，但从这两个函数依赖推不出 F 中原本存在的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">Dept\rightarrow DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> ，即分解为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 之后丢失了函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">Dept\rightarrow DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> ，故 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> 不具有保持函数依赖性</p></li></ol><h2 id="算法集合">算法集合</h2><p>上面提到的很多地方都需要使用到算法来进行求解，限于篇幅以及为了节省脑子，就放在下面这里一起讲了</p><h3 id="属性集闭包算法">属性集闭包算法</h3><p>这一部分内容来自于教材P139，算法4.1，若有问题请以书上为准</p><ul class="lvl-0"><li class="lvl-2"><p>输入：关系模式 R 的属性集 U ，U 上的函数依赖集 F ， 要求出闭包的属性集 X</p></li><li class="lvl-2"><p>处理</p><p>result = X<br>do {<br>if ( F中存在某个函数依赖 Y-&gt;Z , 满足Y <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span> Z )  / <em>即当前找到的闭包的子集 Y 中能够函数决定一个闭包外的属性Z</em> /</p><p>​then result = result <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∪</span></span></span></span> Z / <em>满足条件，就向当前闭包添加新的属性 Z</em> /</p><p>}while ( result 发生变化 )</p></li><li class="lvl-2"><p>输出：最终的闭包结果 result</p></li></ul><p>例如：对于函数依赖集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mi>W</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{X\rightarrow Y,Y\rightarrow Z,W\rightarrow Y\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">}</span></span></span></span> 而言，我们可以求出各个属性集的闭包：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msup><mi>Y</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">XY^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XYZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> ；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msup><mi>W</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">XW^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi><mi>Z</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">XYZW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> ；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><msup><mi>Z</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">XZ^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> ：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XYZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">XW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 的属性集<strong>闭包是全体属性</strong>，我们可以将 XW 作为<strong>关系模式的候选码</strong></p><h3 id="多属性函数依赖集候选码求解算法">多属性函数依赖集候选码求解算法</h3><p>这一部分内容来自于教材P140，算法4.2，若有问题请以书上为准</p><p>在了解如何求解候选码之前，我们先了解一下关系模式的属性依赖。根据函数依赖集中的函数依赖情况，我们可以将属性分为以下几类：</p><ul class="lvl-0"><li class="lvl-2"><p>L类：<strong>仅出现</strong>在函数依赖箭头<strong>左部</strong>的属性</p></li><li class="lvl-2"><p>R类：<strong>仅出现</strong>在函数依赖箭头<strong>右部</strong>的属性</p></li><li class="lvl-2"><p>N类：函数依赖左右两边<strong>都没有出现过</strong>的属性</p></li><li class="lvl-2"><p>LR类：函数依赖左右两边<strong>都出现过</strong>的属性</p></li></ul><p>对于这些类别，我们能初步得出一些结论：</p><ul class="lvl-0"><li class="lvl-2"><p>若 X 是 <strong>L 类属性</strong>，则 X 必为<strong>任一候选码</strong></p></li><li class="lvl-2"><p>若 X 是 <strong>L 类属性</strong>，若 X 是 <strong>L 类属性</strong>，且 X<sup>+</sup> 包含了关系模式 R 的<strong>全部属性</strong>，则 X 必为 R 的<strong>唯一候选码</strong>，即<strong>主键</strong></p></li><li class="lvl-2"><p>若 X 是 <strong>R 类属性</strong>，则 X <strong>不会是主属性</strong></p></li><li class="lvl-2"><p>若 X 是 <strong>N 类属性</strong>，则 X <strong>必然会是主属性</strong></p></li><li class="lvl-2"><p>若 X 是 <strong>L 类属性和 N 类属性组合成的属性集</strong>，且 X<sup>+</sup> 包含了关系模式 R 的<strong>全部属性</strong>，则 X 必为 R 的<strong>唯一候选码</strong>，即<strong>主键</strong></p></li><li class="lvl-2"><p>若 X 是 <strong>LR 类属性</strong>，则 X 可能是主属性，也可能不是主属性</p></li></ul><p>求解<strong>所有候选码</strong>的算法如下：</p><ul class="lvl-0"><li class="lvl-2"><p>输入：关系模式 R 及其函数依赖集 F</p></li><li class="lvl-2"><p>处理：</p><ol><li class="lvl-5">将所有属性划分为 L、R、N、LR 类，并令 <strong>X</strong> 作为所有 <strong>L、N 类</strong>属性的集合；<strong>Y</strong> 作为所有<strong>LR</strong> 类属性的集合；</li><li class="lvl-5">求出 <strong>X<sup>+</sup></strong> ，若能够得到 R 的<strong>全部属性</strong>，转5；否则转3</li><li class="lvl-5">从 Y 中任取一个属性 A ，求出 XA<sup>+</sup> ，若包含了<strong>R的所有属性</strong>，则转4，否则调换另一个属性 B，重复进行这一过程，直到 Y 中<strong>所有属性都尝试过</strong></li><li class="lvl-5">如果找到了所有候选码，则转5；否则不断从 Y 中取两个、三个属性，直到 （X <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∪</span></span></span></span> 取出的属性属性）包含<strong>R的全部属性</strong></li><li class="lvl-5">输出当前的结果</li></ol></li><li class="lvl-2"><p>输出：所有的候选码</p></li><li class="lvl-2"><p>注意：当所有的候选码<strong>涵盖了 R 的全部属性</strong>时，我们就能够确定<strong>找到了所有的候选码</strong></p></li></ul><h3 id="最小函数依赖集求解算法">最小函数依赖集求解算法</h3><p>这一部分内容来自于教材P143，算法4.3，若有问题请以书上为准</p><p>最小函数依赖集的算法分为一下三步：</p><ol><li class="lvl-3"><p>通过<strong>分解律</strong>消除函数依赖<strong>右边的复数属性</strong>，令新的函数依赖集为 <strong>G</strong></p></li><li class="lvl-3"><p>分解函数依赖<strong>左边的复数属性</strong>，以函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Y</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">XY\rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 为例，具体方法如下：</p><ul class="lvl-2"><li class="lvl-5">找到 X 与 Y 的各自的属性集闭包，判断能否单独推导出 A ，<strong>哪个不能就是多余的</strong>，由此消解函数依赖左边的复数属性</li></ul></li><li class="lvl-3"><p>消除函数中的冗余依赖：去掉一个函数依赖（例如为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> ），对于剩下的函数依赖查看是否能够将其推导出来，若能，则证明冗余，将冗余的函数依赖去掉</p></li></ol><h3 id="追逐法算法">追逐法算法</h3><p>这一部分内容来自于教材P146，算法4.4，若有问题请以书上为准</p><p>（我觉得正篇里面讲得挺清晰的，就这样吧）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Armstrong公理&quot;&gt;Armstrong公理&lt;/h2&gt;
&lt;h3 id=&quot;函数依赖中需要解决的问题&quot;&gt;函数依赖中需要解决的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如何从一些已知的函数依赖去判断另外一些函数依赖是否成立&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;如果在某个关</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="规范化" scheme="https://elementgc.github.io/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    <category term="函数依赖" scheme="https://elementgc.github.io/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（8）--模式设计、函数依赖</title>
    <link href="https://elementgc.github.io/2023/06/05/data-base-note-8/"/>
    <id>https://elementgc.github.io/2023/06/05/data-base-note-8/</id>
    <published>2023-06-05T01:59:24.000Z</published>
    <updated>2023-06-05T04:53:31.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式设计问题">模式设计问题<a href="%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">#</a></h2><p>这一章的存在主要是前两篇<a href="/2023/06/04/data-base-note-6/" title="范式的学习1">范式的学习1</a>和<a href="/2023/05/27/data-base-note-2/" title="范式的学习2">范式的学习2</a>里面没有提到教科书里面用到的知识点<strong>Armstrong公理和闭包</strong>，所以重新在慕课上找了一下，重新学习并记录，故知识点可能和前面的有所重复</p><h3 id="关系模式">关系模式</h3><p>关系模式的五元组表示：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span>：</p><ul class="lvl-0"><li class="lvl-2"><p>R <strong>为关系模式的名称</strong></p></li><li class="lvl-2"><p>U <strong>为关系模式的属性组</strong>，即属性名称的集合</p></li><li class="lvl-2"><p>D 是 U 中的属性所来自的域，即属性的取值范围</p></li><li class="lvl-2"><p>DOM 是属性向域的映像集合</p></li><li class="lvl-2"><p>F <strong>是属性之间数据的依赖关系</strong></p></li></ul><p>加粗的三个部分是关系模式最为主要的三个信息，故一个关系模式也可以简化成三元组表示**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span>**</p><p>现有一个关系模式医院信息系统：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mi>o</mi><mi>s</mi><mi>p</mi><mi>i</mi><mi>t</mi><mi>a</mi><mi>l</mi><mo stretchy="false">(</mo><mspace linebreak="newline"></mspace><mo stretchy="false">{</mo><mi>D</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>D</mi><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo separator="true">,</mo><mi>D</mi><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo separator="true">,</mo><mi>P</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>F</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>D</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>P</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mi>D</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>→</mo><mi>D</mi><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mi>D</mi><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo>→</mo><mi>D</mi><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">}</mo><mspace linebreak="newline"></mspace><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hospital(\\\{Dname,Dlevel,Dsalary,Pname,Fsum\},\\\{(Dname,Pname)\rightarrow Fsum,\\Dname\rightarrow Dlevel,\\Dlevel\rightarrow Dsalary\}\\)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Hos</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">Ds</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">ry</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mclose">}</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Ds</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">ry</span><span class="mclose">}</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></span></p><p>其中：Dname 表示医生姓名；Dlevel 表示医生的职称；Dsalary 表示医生工资，Pname 表示患者姓名，Fsum 表示医生为病人就诊一次需要收取的费用。一名医生可以为多个患者看病，一名患者也可以找多位医生就诊，即需要将<strong>Dname与Pname共同作为主键</strong>；具体数据信息如下图所示：</p><p><img src="https://elementgc.github.io/2023/06/05/data-base-note-8/p2.png" alt="关系模式信息" width="300" height="280"></p><h3 id="关系模式中存在的问题">关系模式中存在的问题</h3><p>根据上述的关系模式以及其函数依赖关系，我们可以做出依赖关系图如下所示：</p><p><img src="https://elementgc.github.io/2023/06/05/data-base-note-8/p1.png" alt="依赖关系图"></p><p>从图中我们可以直观地看出关系模式存在的问题：</p><ul class="lvl-0"><li class="lvl-2"><p>数据冗余：</p><p>一个医生给多个病人就诊，导致其他信息如 Dlevel 和 Dsalary <strong>重复多次出现</strong></p></li><li class="lvl-2"><p>更新异常：</p><p>一名医生的职称发生变化，其在表中 Dlevel 和 Dsalary 都要同时进行对应的变化，否则会造成数据的不一致</p></li><li class="lvl-2"><p>删除异常：</p><p>若是一名患者只来找过一个医生看病，且这个医生之后被调走或者退休，不仅这名医生的信息会被删除，患者的看病信息同样也会消失</p></li><li class="lvl-2"><p>插入异常：</p><p>由于病人找医生就诊支付的费用需要有<strong>病人</strong>和<strong>医生</strong>两个信息同时存在，故该表中的 Dname 和 Pname 作为主键都必须非空。但新医生入职后却有一段时间会处于没有就诊记录这一状态，导致其 Pname 不存在值，无法插入信息</p></li></ul><h3 id="数据依赖">数据依赖</h3><p>数据依赖是<strong>导致数据冗余的原因</strong>，数据依赖中最为主要的一部分是<strong>函数依赖</strong>，除此之外，还有<strong>多值依赖</strong>和<strong>函数依赖</strong>。</p><h4 id="函数依赖的特点">函数依赖的特点</h4><ul class="lvl-0"><li class="lvl-2"><p>函数依赖指的是一个关系表中<strong>属性之间</strong>的关系</p></li><li class="lvl-2"><p>函数依赖是属性在<strong>语义上</strong>的关联特性</p></li><li class="lvl-2"><p>函数依赖关注的是<strong>两个属性或属性集之间</strong>的约束</p></li><li class="lvl-2"><p>数据库的设计者根据对关系中的<strong>属性语义或业务需求</strong>，理解并且确定函数依赖，确定约束所有元组的函数依赖集</p></li></ul><h4 id="函数依赖符号">函数依赖符号</h4><ul class="lvl-0"><li class="lvl-2"><p>R ：表示一个关系模式</p></li><li class="lvl-2"><p>U = {A1, A2, …} ：表示 R 的属性组</p></li><li class="lvl-2"><p>F ：表示 R 中函数依赖的集合</p></li><li class="lvl-2"><p>t[A] ：表示元组 t 在属性 A 上的取值，如设置t为第二行元组，可知道 t[Dname] = ‘杨勋’</p></li><li class="lvl-2"><p>FD ：函数依赖的首字母缩写</p></li></ul><p>以此，我们来看<strong>函数依赖的定义</strong>：</p><p>设有一关系模式 <em>R(U)</em><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">= s[X] 时，能够</label><strong>同时确定出 t[Y] = s[Y]</strong> ，则我们称 Y 函数依赖与 X ，或者 X 函数决定 Y ，也可称 FD X —&gt; Y 在关系模式 <em>R(U)</em> 上成立、</p><h4 id="平凡函数依赖——函数依赖中的废话：">平凡函数依赖——函数依赖中的废话：</h4><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y\subseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> ，则一定有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 成立，即当我们知道了医生和患者的名字，那我们一定知道了医生和患者的名字*<s>(新概念废话)</s>*。</p><ul class="lvl-0"><li class="lvl-2"><p>平凡函数依赖一定成立，不产生新的语义</p></li><li class="lvl-2"><p>一般说的函数依赖都是非平凡函数依赖</p></li></ul><h4 id="完全-部分函数依赖——第二范式的判断标准：">完全/部分函数依赖——第二范式的判断标准：</h4><p>设 X、Y 是某关系的不同属性集，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> ，同时对于 X 的真子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X&#x27;\subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 而言，不存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> ，就说明 Y 是完全函数依赖于 X，记做 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo><mover><mo><mo>⟶</mo></mo><mi>F</mi></mover></mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{F}{\longrightarrow}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> ，否则就是部分依赖于 X ，记做： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo><mover><mo><mo>⟶</mo></mo><mi>P</mi></mover></mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{P}{\longrightarrow}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003em;vertical-align:-0.011em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></p><ul class="lvl-0"><li class="lvl-2"><p>完全函数依赖通常用来表示函数依赖的决定因子中最小的属性集</p></li><li class="lvl-2"><p>如果 Y 完全函数依赖于 X ，则必须满足以下条件：</p><ul class="lvl-2"><li class="lvl-4">X 函数决定 Y</li><li class="lvl-4">X 的任何真子集都不能函数决定 Y</li></ul></li></ul><h4 id="传递-直接函数依赖——第三范式判断标准">传递/直接函数依赖——第三范式判断标准</h4><p>设 X , Y , Z 是某个关系模式中互不相同互不交叉的属性集，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>↛</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y,Y\not\rightarrow X,Y\rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> ，则称 Z 对 X 具有传递函数依赖</p><p>若上述条件中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y\rightarrow X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> ，即存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↔</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \leftrightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> ，则说明 X 与 Y 是一一对应的关系，此时我们称 X 直接函数决定 Z ，即 Z 和 Y 都直接函数依赖与 X 。</p><hr><h2 id="学习资源">学习资源</h2><ol><li class="lvl-3"><p><a href="https://www.icourse163.org/learn/UESTC-1458643166?tid=1470104698#/learn/content?type=detail&amp;id=1253788284">数据库原理及应用_中国大学MOOC(慕课) (icourse163.org)</a></p></li></ol><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模式设计问题&quot;&gt;模式设计问题&lt;a href=&quot;%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这一章的存在主要是前两篇&lt;a href=&quot;/2023/06/04/data-base-note-6/&quot; title</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="规范化" scheme="https://elementgc.github.io/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    <category term="函数依赖" scheme="https://elementgc.github.io/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（7）--范式与规范化</title>
    <link href="https://elementgc.github.io/2023/06/04/data-base-note-7/"/>
    <id>https://elementgc.github.io/2023/06/04/data-base-note-7/</id>
    <published>2023-06-04T06:03:12.000Z</published>
    <updated>2023-06-06T07:10:26.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数依赖">函数依赖<a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">#</a></h2><h3 id="定义">定义</h3><p>设<code>R(U)</code>是一个属性集<em>U</em>上的关系模式，<em>X</em> , <em>Y</em> 是 <em>U</em> 的子集。对于 <em>R(U)</em> 的任意一个可能的关系 <em>r</em> ，<em>r</em> 中不可能存在两个元组在 <em>X</em> 上的属性值相等，且在 <em>Y</em> 上属性值不等，则称<strong>X 函数确定Y</strong>或者<strong>Y函数依赖于X</strong>，记做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，<strong>其中， X 称为这个函数依赖的决定因素</strong></p><p>翻译成人话就是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>t</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>S</mi><mi>S</mi><mi>e</mi><mi>x</mi><mo separator="true">,</mo><mi>S</mi><mi>A</mi><mi>g</mi><mi>e</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Student(SNo,SName,SSex,SAge,SDept)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">am</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">SS</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mclose">)</span></span></span></span></span></p><p>在这样一个关系模式中，对于其中的一个或者几个属性，比如说 <em>SNo</em> 作为X，<em>SDept</em> 作为 Y ，如果不存在有两行数据，这两行数据的 <em>SNo</em> 是相同的，但是对应的 <em>SDept</em> 是不一样的，即<strong>每一个确定的 <em>SNo</em> 都可以唯一确定一个<em>SDept</em></strong>，记做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">SNo\rightarrow SDept</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span></span></span></span></p><h3 id="查找函数依赖">查找函数依赖</h3><ol><li class="lvl-3"><p>找候选码</p><p>通常函数依赖都是<strong>主属性</strong>函数确定<strong>非主属性</strong>，或者<strong>非主属性</strong>函数依赖于<strong>主属性</strong>，所以我们先找到候选码，确定主属性</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>主码</mtext><mo>∈</mo><mtext>候选码</mtext><mo>=</mo><mtext>主属性</mtext></mrow><annotation encoding="application/x-tex">主码\in 候选码=主属性</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">主码</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">候选码</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">主属性</span></span></span></span></span></p></li><li class="lvl-3"><p>候选码与非主属性之间建立函数依赖，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>候选码</mtext><mo>→</mo><mtext>非主属性</mtext></mrow><annotation encoding="application/x-tex">候选码\rightarrow 非主属性</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">候选码</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">非主属性</span></span></span></span>，候选码之间相互依赖，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>候选码</mtext><mo>↔</mo><mtext>候选码</mtext></mrow><annotation encoding="application/x-tex">候选码\leftrightarrow 候选码</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">候选码</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">候选码</span></span></span></span>，</p></li><li class="lvl-3"><p>若是非主属性之间具有决定的关系，那也可以建立依赖，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>非主属性</mtext><mo>→</mo><mtext>非主属性</mtext></mrow><annotation encoding="application/x-tex">非主属性\rightarrow 非主属性</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">非主属性</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">非主属性</span></span></span></span></p></li></ol><p>注意：</p><ul class="lvl-0"><li class="lvl-2"><p>函数依赖是术语语义范畴的概念，能不能形成依赖<strong>只能根据数据的语义来确定</strong></p><ul class="lvl-2"><li class="lvl-4">例如：当确定没有重名的情况出现后，才能形成依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>姓名</mtext><mo>→</mo><mtext>年龄</mtext></mrow><annotation encoding="application/x-tex">姓名\rightarrow 年龄</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">姓名</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">年龄</span></span></span></span>，否则这个依赖不成立</li></ul></li></ul><h3 id="函数依赖的种类">函数依赖的种类</h3><blockquote><p>取自上一篇末尾，这一部分又有完善</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>完全依赖</strong> + 部分依赖</p><ul class="lvl-2"><li class="lvl-4">(SNo,CNo) --&gt; Grade 中，只有 SNo 与 CNo 组合在一起才能够决定出 Grade ，故称该依赖为完全函数依赖</li><li class="lvl-4">(SCo,CNo) --&gt; SDept --&gt; MName 中，SDept 不能通过主属性 CNo 决定，故称为部分函数依赖</li></ul></li><li class="lvl-2"><p>传递依赖</p><ul class="lvl-2"><li class="lvl-4">(SCo,CNo) --&gt; SDept --&gt; MName 中，通过 SDept 就能够知道 MName ，依赖关系发生了传递，故称为传递依赖</li><li class="lvl-4">若是存在 X&lt;–&gt;Y ，且 Y --&gt; Z ，我们不能说 Z 传递依赖于 X ，而是直接依赖</li></ul></li><li class="lvl-2"><p>平凡依赖 + <strong>非平凡依赖</strong></p><ul class="lvl-2"><li class="lvl-4">通俗点来讲，平凡依赖就是我依赖于我自己，这样的依赖是没有意义的，我们之后遇到也不需要考虑</li></ul></li></ul><h2 id="码">码</h2><p>详细部分请看<a href="/2023/05/27/data-base-note-2/#关系">数据库学习报告 - 2</a>中的内容，这里只做简单的复习梳理</p><h3 id="候选码">候选码</h3><ul class="lvl-0"><li class="lvl-2"><p>能够唯一确定其他属性、区分不同元组的属性或属性组</p></li><li class="lvl-2"><p>候选码包括主码</p></li><li class="lvl-2"><p>若一个表的属性组中全是候选码，称其为<strong>全码</strong>。通常这个时候就是要所有属性都在一起才能确定一个元组</p></li></ul><h3 id="主属性与非主属性">主属性与非主属性</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>包含</strong>在任何一个候选码中的属性，都可以成为主属性</p></li><li class="lvl-2"><p>任何候选码都不包含的属性，成为非主属性</p></li><li class="lvl-2"><p>主属性本身<strong>可以不是</strong>候选码，但一定得是候选码中的一员</p></li><li class="lvl-2"><p>主码一定是候选码，候选码不一定是主码</p></li></ul><h2 id="范式-normal-form">范式(normal form)</h2><p>定义：</p><ul class="lvl-0"><li class="lvl-2"><p>范式是复合某一种级别的关系模式的集合</p></li><li class="lvl-2"><p>关系数据库中的关系满足不同程度，就称为不同范式</p></li><li class="lvl-2"><p>范式有以下几种</p><ul class="lvl-2"><li class="lvl-4"><strong>第一范式</strong>(1NF)</li><li class="lvl-4"><strong>第二范式</strong>(2NF)</li><li class="lvl-4"><strong>第三范式</strong>(3NF)</li><li class="lvl-4">BC范式(BCNF)</li><li class="lvl-4">第四范式(4NF)</li><li class="lvl-4">第五范式(5NF)</li></ul><p>他们的关系如下</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>2</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>3</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mi>B</mi><mi>C</mi><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>4</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>5</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">1NF\supset 2NF\supset 3NF\supset BCNF\supset 4NF\supset 5NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BCNF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span></span></p></li><li class="lvl-2"><p>BC 范式术语第三范式的特殊情况，但还<strong>达不到第四范式</strong></p></li><li class="lvl-2"><p>第四、第五范式属于<strong>多值依赖</strong>范畴</p></li><li class="lvl-2"><p>较低级范式的关系模式可以通过<strong>模式分解</strong>的方法转换为<strong>多个</strong>高一级范式的关系模式，这个过程叫做<strong>规范化</strong></p></li></ul><h3 id="第一范式">第一范式</h3><p>第一范式是关系数据库最基本的阶段，其规范内容为：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>关系表的每一个属性都是不可再分的</strong>，即<a href="/2023/05/27/data-base-note-2/#关系的性质">“关系的性质”</a>最后一条</p></li><li class="lvl-2"><p>关系表中的列或者行不能再细分成多个小列，就像下面这种就是不行的</p><table bgcolor="white">    <tr align="center">        <td colspan="2">这是一列</td>    </tr>    <tr>        <td>这是再分的小列</td>        <td>这是再分的小列</td>    </tr></table></li></ul><h3 id="第二范式">第二范式</h3><p>判断第二范式的前提条件是满足第一范式，然后再考虑一下条件：</p><ul class="lvl-0"><li class="lvl-2"><p>每个非主属性都完全函数依赖与任何一个候选码</p></li><li class="lvl-2"><p>即不存在部分函数依赖</p></li><li class="lvl-2"><p>故达成第二范式，就是要消除<strong>非主属性对主属性的部分函数依赖</strong></p></li></ul><p>现在我们对下面的关系模式进行分析</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>t</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Student(SNo,SDept,SLoc,CNo,Grade)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span></p><p><em>SLoc</em> 表示每个学生的住处，能看出这个关系表的主属性为(SNo, CNo)</p><h4 id="观察函数依赖">观察函数依赖</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo stretchy="false">)</mo><mo><mover><mo><mo>⟶</mo></mo><mi>F</mi></mover></mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo stretchy="false">)</mo><mo><mover><mo><mo>⟶</mo></mo><mi>P</mi></mover></mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo stretchy="false">)</mo><mo><mover><mo><mo>⟶</mo></mo><mi>P</mi></mover></mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mspace linebreak="newline"></mspace><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mspace linebreak="newline"></mspace><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mspace linebreak="newline"></mspace><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">(SNo,CNo)\stackrel{F}{\longrightarrow}Grade\\(SNo,CNo)\stackrel{P}{\longrightarrow}SDept \\(SNo,CNo)\stackrel{P}{\longrightarrow}SLoc\\SNo\rightarrow SDept\\SNo\rightarrow SLoc\\SDept\rightarrow SLoc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5393em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.5393em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.5393em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.711em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span></span></span></span></span></p><p>这样可以画出依赖关系图：</p><p><img src="https://elementgc.github.io/2023/06/04/data-base-note-7/p1.png" alt="函数依赖关系图" width="400" height="250"></p><p>可以看出，现在的这个表<strong>存在着部分函数依赖</strong>和传递函数依赖，不属于第二范式2NF</p><h4 id="模式分解">模式分解</h4><p>模式分解的主要目的，就是让原本不满足范式要求的关系模式变为若干个满足规范的关系模式</p><p><img src="https://elementgc.github.io/2023/06/04/data-base-note-7/p2.png" alt="第二范式模式分解" width="450" height="250"></p><p>如图所示，我们将<strong>部分依赖部分单独给提了出来</strong>，这样就将一个关系模式分解成了两个关系模式，可以将其命名为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>C</mi><mi>G</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SCG(SNo,CNo,Grade)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">SCG</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>D</mi><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SDL(SNo,SDept,SLoc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mclose">)</span></span></span></span>，再次观察其函数依赖，能够发现已经满足了第二范式</p><p><em><s>这里给一下GPT给出的拆分理由</s></em> 还是不看了，怎么看都觉得离谱</p><h3 id="第三范式">第三范式</h3><p>实现第二范式之后，关系模式中可能还存在着传递函数依赖，从而导致数据冗余、增、删、改异常等情况，故若需要完善，还要化成第三范式。第三范式的要求如下：</p><ul class="lvl-0"><li class="lvl-2"><p>非主属性对主属性不要有传递函数依赖，即：</p><ul class="lvl-2"><li class="lvl-4">不能有 <strong>主属性 --&gt; 非主属性 --&gt; 非主属性</strong> 这种传递依赖关系链</li></ul></li></ul><p>以上面得出的两个第二范式为例：</p><ol><li class="lvl-3"><p>判断函数依赖</p><ul class="lvl-2"><li class="lvl-5"><p>关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>C</mi><mi>G</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SCG(SNo,CNo,Grade)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">SCG</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>不存在传递函数依赖，只有一个完全函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo stretchy="false">)</mo><mo>→</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">(SNo,CNo)\rightarrow Grade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span>，故满足第三范式</p></li><li class="lvl-5"><p>关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>D</mi><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SDL(SNo,SDept,SLoc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mclose">)</span></span></span></span>仍然存在非主属性对主属性的传递函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">SNo\rightarrow SDept\rightarrow SLoc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span></span></span></span>,显然还是不满足第三范式，还需要接着模式分解</p></li></ul></li><li class="lvl-3"><p>模式分解：</p><p>解决传递依赖最好的办法就是让这个传递不存在，若是通过分解的方法来消除传递依赖的话，只需要<strong>将 1-2-3 中的 1-2 与 2-3 分开即可</strong>，即将关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>D</mi><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SDL(SNo,SDept,SLoc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mclose">)</span></span></span></span>分解成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>D</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SD(SNo,SDept)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mclose">)</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>L</mi><mo stretchy="false">(</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>L</mi><mi>o</mi><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DL(SDept,SLoc)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mclose">)</span></span></span></span> 两组关系模式即可</p></li></ol><h2 id="小结">小结</h2><p>关系模式规范化的处理步骤：</p><ol><li class="lvl-3"><p>找到关系模式的候选码，区分出主属性与非主属性</p></li><li class="lvl-3"><p>找到主属性与非主属性自检的依赖关系，确定是<strong>完全依赖还是部分依赖</strong>，是不是<strong>传递函数依赖</strong></p></li><li class="lvl-3"><p>通过模式分解的方法来分解不符合规范的关系模式</p><ul class="lvl-2"><li class="lvl-5">规范化为第二范式，要将原本对于主属性的部分函数依赖中，被依赖的部分单独提出来作为一个新表，通过这种方法来消除非主属性对主属性的部分函数依赖</li><li class="lvl-5">规范化为第三范式，要将对于主属性的传递依赖拦腰折断，让分解出来的新表中主属性与中间属性在一个表，中间属性和传递链后面在一个表</li></ul></li><li class="lvl-3"><p>进行关系模式规范化的目的是<strong>减少数据冗余、避免出现关系模式的增、删、改异常</strong></p></li></ol><hr><h2 id="学习资源">学习资源</h2><ol><li class="lvl-3"><p><a href="https://www.bilibili.com/video/BV1wv4y1m7J2/?spm_id_from=333.788&amp;vd_source=c4ae5dea1b3b903a045fbaa6f2a00bb5">数据库第6章 关系数据理论（第二部分：范式理论 1NF-2NF-3NF）_哔哩哔哩_bilibili</a></p></li></ol><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数依赖&quot;&gt;函数依赖&lt;a href=&quot;#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;设&lt;code&gt;R(U)&lt;/code&gt;是一个属性集&lt;em&gt;U&lt;/em&gt;上的关系模式</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="规范化" scheme="https://elementgc.github.io/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    <category term="范式" scheme="https://elementgc.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（6）--关系模式</title>
    <link href="https://elementgc.github.io/2023/06/04/data-base-note-6/"/>
    <id>https://elementgc.github.io/2023/06/04/data-base-note-6/</id>
    <published>2023-06-04T04:22:13.000Z</published>
    <updated>2023-06-05T02:00:26.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系模式">关系模式<a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">#</a></h2><h3 id="数据库可能存在的问题">数据库可能存在的问题</h3><ul class="lvl-0"><li class="lvl-2"><p>数据冗余</p></li><li class="lvl-2"><p>增、删、改异常</p></li></ul><h3 id="如何发现问题">如何发现问题</h3><p>以学习资源<sup>1</sup>中的例子，当前有一个关系模型</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>t</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>M</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Student(SNo,SDept,MName,CNo,Grade)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">St</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">MN</span><span class="mord mathnormal">am</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span></p><p>其中的属性分别为：学生学号、学生专业、系主任名字、课程名、课程成绩</p><ol><li class="lvl-3"><p>找到关系模式的主键</p><ul class="lvl-2"><li class="lvl-5">通常是将序号或者序号的组合作为主码</li><li class="lvl-5">例中的主码为（SNo, CNo）的组合</li><li class="lvl-5">因为一个学生与一门课程能够单独对应出唯一的一组元组</li></ul></li><li class="lvl-3"><p>数据冗余</p><ul class="lvl-2"><li class="lvl-5">一个表里面完全一样的数据被多次重复</li><li class="lvl-5">例中学生的专业与系主任名字是唯一对应的，所以存在数据冗余</li></ul></li><li class="lvl-3"><p>增加异常</p><ul class="lvl-2"><li class="lvl-5">在一个合理的条件下添加数据，但是会被约束导致无法添加</li><li class="lvl-5">新转入一个学生的时候还没有选课，此时的课程名部分本该为空，但是由于其作为主键，不能置空，存在增加异常</li></ul></li><li class="lvl-3"><p>删除异常</p><ul class="lvl-2"><li class="lvl-5">删除一组或多组数据后会导致一些信息完全消失找不到</li><li class="lvl-5">学生毕业之后所有数据全部清空，结果找不到每一个系对应的系主任的名字</li></ul></li><li class="lvl-3"><p>修改异常</p><ul class="lvl-2"><li class="lvl-5">当某个对应的数据信息发生变动时，会引发大规模的数据变动</li><li class="lvl-5">系主任发生人事调动，一个学生表中所有对应专业的系主任名字都得改</li></ul></li></ol><h3 id="为什么会数据表会有问题">为什么会数据表会有问题</h3><h4 id="函数">函数</h4><p>数学中的函数，存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，这表示通过一个数值 x ，能够唯一确定出一个 y 来与 x 对应。延伸到关系模式中，就是<strong>通过一个（组）主码，就能够决定出唯一一组别的（非主）属性</strong></p><h4 id="分析函数中的依赖关系">分析函数中的依赖关系</h4><p>上面例子中的关系模式，存在的函数依赖有：</p><ul class="lvl-0"><li class="lvl-2"><p>(SNo,CNo) --&gt; Grade</p></li><li class="lvl-2"><p>(SCo,CNo) --&gt; SDept --&gt; MName</p></li></ul><p>第一个函数依赖是合适的：</p><p>当且仅当有唯一的学生和课程名的时候才能找到对应的课程成绩</p><p>第二个函数依赖是不合适的：</p><p>知道学号之后，就能够直接确定专业与系主任，<strong>而不再需要所选课程这一信息</strong></p><p>即<strong>非主属性只和主键的一部分有关，和另一部分无关</strong></p><h3 id="数据依赖关系">数据依赖关系</h3><ul class="lvl-0"><li class="lvl-2"><p>函数依赖——<strong>需要</strong></p><p>即在一个关系模式中，能够通过一个主键（x）找到唯一的对应元组（y）</p></li><li class="lvl-2"><p>多值依赖——不需要</p><p>通过一个主键（x）会找到很多和对应的元组（y）</p></li></ul><h4 id="函数依赖关系">函数依赖关系</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>完全依赖</strong> + 部分依赖</p><ul class="lvl-2"><li class="lvl-4">(SNo,CNo) --&gt; Grade 中，只有 SNo 与 CNo 组合在一起才能够决定出 Grade ，故称该依赖为完全函数依赖</li><li class="lvl-4">(SCo,CNo) --&gt; SDept --&gt; MName 中，SDept 不能通过主属性 CNo 决定，故称为部分函数依赖</li></ul></li><li class="lvl-2"><p>传递依赖</p><ul class="lvl-2"><li class="lvl-4">(SCo,CNo) --&gt; SDept --&gt; MName 中，通过 SDept 就能够知道 MName ，依赖关系发生了传递，故称为传递依赖</li></ul></li><li class="lvl-2"><p>平凡依赖 + <strong>非平凡依赖</strong></p><ul class="lvl-2"><li class="lvl-4">当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>∈</mo><mi mathvariant="normal">/</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y\in / \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>时，我们称这样的函数依赖关系为平凡依赖，即 (SNo,CNo) --&gt; SNo 这种</li><li class="lvl-4">当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo mathvariant="normal">∉</mo><mi mathvariant="normal">/</mi><mo>⊄</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y\notin / \not\subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>时，我们称这样的函数依赖关系为非平凡依赖，即 (SNo,CNo) --&gt; Grade 这种</li></ul></li></ul><p>其中<strong>加粗</strong>的部分表示是我们<strong>需要的，合适的</strong>函数依赖关系</p><p>我们可以通过上面的分析得到一组函数依赖F：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo>→</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>M</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>S</mi><mi>N</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>N</mi><mi>o</mi><mo stretchy="false">)</mo><mo>→</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F=\{SNo\rightarrow SDept, SDept\rightarrow MName, (SNo, CNo)\rightarrow Grade\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">De</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">MN</span><span class="mord mathnormal">am</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">SN</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">CN</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">}</span></span></span></span></span></p><p><img src="https://elementgc.github.io/2023/06/04/data-base-note-6/p1.png" alt="函数依赖图结构" width="400" height="200"></p><hr><h2 id="学习资源">学习资源</h2><ol><li class="lvl-3"><p><a href="https://www.bilibili.com/video/BV1nG4y157VP/?spm_id_from=333.788&amp;vd_source=c4ae5dea1b3b903a045fbaa6f2a00bb5">数据库第6章 关系数据理论（第一部分：问题的提出 为什么二维表会有问题）</a></p></li></ol><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系模式&quot;&gt;关系模式&lt;a href=&quot;#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;数据库可能存在的问题&quot;&gt;数据库可能存在的问题&lt;/h3&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li clas</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="函数依赖" scheme="https://elementgc.github.io/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（5）--视图与索引</title>
    <link href="https://elementgc.github.io/2023/06/03/data-base-note-5/"/>
    <id>https://elementgc.github.io/2023/06/03/data-base-note-5/</id>
    <published>2023-06-03T01:07:00.000Z</published>
    <updated>2023-06-05T02:01:48.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图">视图</h2><p>视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些<strong>数据仍存放在原来的基本表</strong>中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。视图一经定义，就可以和基本表一样被查询、删除。也可以在一个视图之上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。</p><blockquote><p>视图只存定义，每次查看视图就相当于执行一次语句。</p></blockquote><h3 id="创建视图">创建视图</h3><p>视图的创建很简单，相当于把数据表的创建和查询结合起来，模板为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 [列名<span class="number">1</span>, 列名<span class="number">2</span>, ...]</span><br><span class="line">[<span class="keyword">with</span> <span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">as</span> select_statement [<span class="keyword">with</span> <span class="keyword">check</span> option] </span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span>::<span class="operator">=</span>&#123;</span><br><span class="line">[ENCRIPTION]</span><br><span class="line">[SCHEMABINDING]</span><br><span class="line">[VIEW_METADATA]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通常情况下是不需要列名的，除非有以下情况：</p><ul class="lvl-2"><li class="lvl-4">列是从算术表达式、函数或者常量派生而来的</li><li class="lvl-4">会有两个以上列具有相同的名称</li><li class="lvl-4">某个列的视图内名称与来源列的名称不同</li></ul></li><li class="lvl-2"><p><strong>select_statement</strong>是定义视图的完整<code>select</code>语句，用这个<code>select</code>查询到的结果就会被放入视图中</p></li><li class="lvl-2"><p>check option 表示针对视图的<strong>所有数据修改语句</strong>都必须符合<strong>select_statement</strong>中的条件</p></li><li class="lvl-2"><p>ENCRYTPTION 表示加密，添加了这个就<strong>无法对视图的数据进行修改</strong>了</p></li><li class="lvl-2"><p>SCHEMABINDING 表示与底层引用的数据表进行绑定，添加了这个就<strong>无法对引用的表的架构（如列的数据类型）进行更改</strong>了，</p></li><li class="lvl-2"><p>VIEW_METADATA 这个不用管，这是设置展示的数据信息的。通俗点说，就是让视图看起来和数据表一样，每一列的定义都直接告诉客户端，而不是引用底层的表的定义</p></li></ul><p>实例：</p><p>创建一个展示每个学生平均分的视图：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> S_AVG (学号, 平均成绩) <span class="keyword">as</span> </span><br><span class="line">(<span class="keyword">select</span> SN,<span class="built_in">AVG</span>(SC.Score) <span class="keyword">from</span> S,SC <span class="keyword">where</span> (S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> SN)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> S_AVG</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p1.png" alt="创建一个展示每个学生平均分的视图"></p><blockquote><p>若遇到报错：**“create view 必须是批处理中仅有的语句”**不用管，运行的时候单独运行这一段语句就行</p></blockquote><h3 id="修改视图">修改视图</h3><p>修改视图不是说修改视图的值，而是说修改<strong>视图引用的表</strong>，也就是说是直接更改<code>select</code>部分，其语法格式为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> 视图名[列名<span class="number">1</span>, 列名<span class="number">2</span>, ...] <span class="keyword">as</span> select_statement</span><br></pre></td></tr></table></figure><p>简单来说，就是创建视图的格式，把最前面的<code>create</code>改成<code>alter</code>而已，下面看个实例：</p><p>修改上面的学生平均成绩视图，添加一列学号上去</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> S_AVG (学号, 姓名, 平均成绩)<span class="keyword">as</span> <span class="keyword">select</span> S.SNo,SN, <span class="built_in">AVG</span>(SC.Score) <span class="keyword">from</span> S,SC <span class="keyword">where</span> (S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> SN,S.SNo</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p2.png" alt="修改上面的学生平均成绩视图，添加一列学号上去"></p><ul class="lvl-0"><li class="lvl-2"><p>注意：如果对列是有修改的话，比如说这次的添加列，就需要重新在上面定义一下列名</p></li></ul><h3 id="删除视图">删除视图</h3><p>和删除数据表一样，简单粗暴</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名</span><br></pre></td></tr></table></figure><h3 id="查询视图">查询视图</h3><p>查询视图的原理是：通过视图找到该视图对基本表的定义（也就是先找到视图对于基本表的处理结果）再将查询条件加上去，这一过程可以等价于对<strong>视图所引用的关系表的查询</strong>，称为<strong>视图消解</strong>，举个例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一开始创建的视图为:</span></span><br><span class="line"><span class="comment">create view S_AVG (学号, 姓名, 平均成绩)as select S.SNo,SN, AVG(SC.Score) from S,SC where (S.SNo = SC.SNo) group by SN,S.SNo */</span></span><br><span class="line"><span class="comment">-- 执行对视图的查询：查询学生的姓名、所在的系与平均成绩</span></span><br><span class="line"><span class="keyword">select</span> 姓名, Dept <span class="keyword">as</span> 所在院系, 平均成绩 <span class="keyword">from</span> S_AVG, S <span class="keyword">where</span> 学号<span class="operator">=</span>SNo</span><br><span class="line"><span class="comment">-- 视图消解后等价于</span></span><br><span class="line"><span class="keyword">select</span> SN <span class="keyword">as</span> 姓名, Dept <span class="keyword">as</span> 所在院系, <span class="built_in">AVG</span>(SC.Score) <span class="keyword">as</span> 平均成绩 <span class="keyword">from</span> S,SC <span class="keyword">where</span> (S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> SN, Dept</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p4.png" alt="视图消解前结果"></p><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p3.png" alt="视图消解后查询结果"></p><ul class="lvl-0"><li class="lvl-2"><p>留个问题：为什么这个查询结果的排序会不一样</p></li><li class="lvl-2"><p>已解决：group by 的时候是按照字段的顺序依次逐字段分组的，如果想要排序和上面的一样的话可以先加个学号，group by的时候先放S.SNo，然后外面套一层嵌套查询如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 姓名, 所在院系, 平均成绩 <span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> S.SNo <span class="keyword">as</span> 学号, SN <span class="keyword">as</span> 姓名, Dept <span class="keyword">as</span> 所在院系, <span class="built_in">AVG</span>(SC.Score) <span class="keyword">as</span> 平均成绩 <span class="keyword">from</span> S,SC <span class="keyword">where</span> (S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> S.SNo,SN, Dept) <span class="keyword">as</span> A</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p5.png" alt="嵌套查询结果"></p></li></ul><h3 id="更新视图">更新视图</h3><p>这个就是更改视图中的值，正如前面所说，视图是一个虚表，所以对视图的更改实际上是对视图所引用的关系表的更改，如果要更新的视图包含聚合函数的结果的话，则会发生报错：<code>因其包含派生域或常量域。</code>；或者<code>因为视图或函数 'S_AVG' 包含聚合、DISTINCT 或 GROUP BY 子句或者 PIVOT 或 UNPIVOT 运算符，所以无法进行更新。</code>所以上面的那个很明显就用不了了，我们这里重新创建个视图：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 例3-73 创建一个计算机系老师情况的视图Sub_T</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> Sub_T <span class="keyword">as</span> <span class="keyword">select</span> TNo,TN,Prof <span class="keyword">from</span> T <span class="keyword">where</span> Dept <span class="operator">=</span> <span class="string">&#x27;计算机&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Sub_T</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p6.png" alt="创建一个计算机系老师情况的视图Sub_T"></p><blockquote><p>视图的更新与关系表的更新大差不差，也是分为添加(insert)、修改(update)、删除(delete)三个部分，基本语法也都差不多，下面我们就演示一下对视图操作之后的视图结果和原表结果</p></blockquote><h4 id="添加行—insert">添加行—insert</h4><p>添加一串数据（‘T6’,’李丹’,’教授’）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> Sub_T <span class="keyword">values</span>(<span class="string">&#x27;T6&#x27;</span>,<span class="string">&#x27;李丹&#x27;</span>,<span class="string">&#x27;教授&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Sub_T</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p7.png" alt="添加一串数据（‘T6’,’李丹’,’教授’）"></p><p>可以看到，对于视图的添加是会直接反映到关系表的，对于没有给的数据，就不会添加，而是按照<strong>默认值给null</strong>，而且即使我们是在筛选了计算机系的情况下添加的新数据信息，但是他也<strong>没有在Dept那里加一个计算机</strong>，这也就导致了我们查询Sub_T的时候<strong>没有查询到添加的结果</strong>，就很怪，不如在创建的时候也加个Dept</p><h4 id="修改行—update">修改行—update</h4><p>把Sub_T中刘伟老师的职称改为副教授</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> Sub_T <span class="keyword">set</span> Prof <span class="operator">=</span> <span class="string">&#x27;副教授&#x27;</span> <span class="keyword">where</span> TN <span class="operator">=</span> <span class="string">&#x27;刘伟&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Sub_T</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p8.png" alt="把Sub_T中刘伟老师的职称改为副教授"></p><p>这个很正常，就是在原有的基础上进行更改</p><h4 id="删除行—delete">删除行—delete</h4><p>删除行和添加行一样，也是先通过视图的索引找到后再进行的操作，但是这样有一个问题：</p><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p9.png" alt="删除刚刚添加的李丹"></p><p><strong>我刚刚添加的内容为什么我同操作却删不了</strong> ，究其根本还是添加是添加进了底层的关系表里，而视图中并没有能同步到新添加的数据，所以最后也就是没删掉，也就是说，只能删掉<strong>能通过select</strong>显示出来的内容，如下：</p><p>删掉刘伟</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Sub_T <span class="keyword">where</span> TN <span class="operator">=</span> <span class="string">&#x27;刘伟&#x27;</span></span><br><span class="line"><span class="keyword">select</span><span class="operator">*</span> <span class="keyword">from</span> Sub_T</span><br><span class="line"><span class="keyword">select</span><span class="operator">*</span> <span class="keyword">from</span> T</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/image-20230603155039095.png" alt="image-20230603155039095"></p><h2 id="索引">索引</h2><h3 id="索引的概念">索引的概念</h3><p>在使用数据库的时候，当数据信息过于庞大时，寻找到想要的结果往往很麻烦，这时我们就可以通过索引来提高数据查询的效率。索引的就像一本书的目录，可以通过索引来确定我们需要查找的数据是否存在于数据库中、若存在的话也能知道其存储地址。对于索引，下面是更加准确的定义：</p><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p10.png" alt="索引的概念" width="450" height="250"></p><blockquote><p>无论是哪种索引，都会在提高数据查询速度的同时，降低插入和更新的速度，所以索引的建立要尽可能的少而精</p></blockquote><h3 id="索引的分类">索引的分类</h3><ul class="lvl-0"><li class="lvl-2"><p>聚集索引</p><ul class="lvl-2"><li class="lvl-4">索引项顺序与数据表的物理顺序一致</li><li class="lvl-4">一个基本表上最多一个聚集索引</li><li class="lvl-4">创建<code>primary key</code>约束时，若不存在聚集索引且没有指定唯一非聚集索引，则自动创建主键约束涉及的列的唯一聚集索引</li><li class="lvl-4">以下情况可以使用聚集索引<ul class="lvl-4"><li class="lvl-6">包含有限数量的唯一值的列</li><li class="lvl-6">使用<code>between &gt; &gt;= &lt; &lt;=</code>这类运算符返回的某个范围的值的查询结果</li><li class="lvl-6">返回大型结果集的查询</li></ul></li></ul></li><li class="lvl-2"><p>非聚集索引</p><ul class="lvl-2"><li class="lvl-4">数据和索引分开存储，索引通过指针指向数据存储位置</li><li class="lvl-4">索引中的项目按照索引键值的顺序存储，不必与数据表的物理顺序一致</li></ul></li><li class="lvl-2"><p>唯一值索引</p><ul class="lvl-2"><li class="lvl-4">索引列不包含重复的值</li><li class="lvl-4">聚集索引和非聚集索引都可以是唯一的，一个表上可以有多个唯一非聚集和一个唯一聚集索引</li><li class="lvl-4">创建 <code>primary key</code> 约束和 <code>unique</code> 约束时都会自动为指定的列创建唯一索引</li></ul></li><li class="lvl-2"><p>视图索引</p><ul class="lvl-2"><li class="lvl-4">标准视图的生成开销很大，若需要频繁调用一类视图，可以通过对视图创建唯一聚集索引来提升性能</li><li class="lvl-4">对视图创建唯一聚集索引后结果集就会直接存储在数据库中，如同带有聚集索引的基本表</li><li class="lvl-4">对于很少更新基础表的视图，使用索引视图的效果更好，否则还是别这么弄了</li><li class="lvl-4">对于基础表数据以批处理的形式<strong>定期更新</strong>、且在<strong>两次更新之间主要作为只读数据处理</strong>，可以通过在<strong>更新前删除所有索引视图</strong>、<strong>更新后重新生成索引视图</strong>的方式，提高批处理的更新性能</li></ul></li></ul><h3 id="创建索引">创建索引</h3><p>创建索引的模板为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">UNION</span>] [clustered<span class="operator">|</span>nonclustered] index 索引名</span><br><span class="line"><span class="keyword">on</span> 表名<span class="operator">/</span>视图名</span><br></pre></td></tr></table></figure><p>例：为SC表在SNo和CNo上建立唯一索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index SCIndex <span class="keyword">on</span> SC(SNo,CNo)</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sys.indexes <span class="keyword">WHERE</span> object_id <span class="operator">=</span> OBJECT_ID(<span class="string">&#x27;SC&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p11.png" alt="SC表上的索引"></p><h3 id="查看索引">查看索引</h3><p>使用Sp_helpindex 可以查看一个表中所有的索引信息，如：</p><p>查看SC表中所有索引信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_helpindex SC</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p12.png" alt="查看SC表中所有索引信息"></p><p>也可以通过Sp_rename来更改索引的名字</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_helpindex SC</span><br><span class="line"><span class="keyword">exec</span> sp_rename <span class="string">&#x27;SC.SCIndex &#x27;</span>, <span class="string">&#x27;SC_index&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/03/data-base-note-5/p13.png" alt="索引的名字"></p><h3 id="删除索引">删除索引</h3><p>删除某个表或视图的索引的模板为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 表名<span class="operator">/</span>视图名.索引名</span><br><span class="line">或</span><br><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名<span class="operator">/</span>视图名</span><br></pre></td></tr></table></figure><h3 id="修改索引">修改索引</h3><p>书上这里巴巴拉拉降了一大堆事一点都不想看了，也没个实例也不想试，等什么时候想起来弄了再说吧</p><hr><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图&quot;&gt;视图&lt;/h2&gt;
&lt;p&gt;视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些&lt;strong&gt;数据仍存放在原来的基本表&lt;/strong&gt;中。所以一旦基本表中的数据发生变化，从视图中查询出</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MYSQL" scheme="https://elementgc.github.io/tags/MYSQL/"/>
    
    <category term="SQL Server Management System" scheme="https://elementgc.github.io/tags/SQL-Server-Management-System/"/>
    
    <category term="SSMS" scheme="https://elementgc.github.io/tags/SSMS/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（4）--数据表中的数据操作增、改、删</title>
    <link href="https://elementgc.github.io/2023/06/02/data-base-note-4/"/>
    <id>https://elementgc.github.io/2023/06/02/data-base-note-4/</id>
    <published>2023-06-02T06:19:40.000Z</published>
    <updated>2023-06-05T02:02:07.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本介绍">基本介绍</h2><p><s><em>（这一部分已经少到需要做基本介绍来充数了么？）</em></s></p><p>数据表的操作相比起查询来说不要简单太多，但也是数据库系统管理中不可或缺的一部分，包括增、改、删三大部分，接下来进行逐一讲解</p><h2 id="添加数据">添加数据</h2><p>添加数据主要是在数据表创建之初用的比较多，后面再使用就是有新数据加入的时候直接添加到最后面。因为数据表里面存储的数据默认来说都是无序的元组集合，按道理来说并不需要说什么在中间插入这种要求，所以咱也不弄那么多复杂的，就直说最常用的在后面添加的方法：</p><p>添加记录的模板为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (列<span class="number">1</span>,列<span class="number">2</span>,...) <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...)</span><br></pre></td></tr></table></figure><p>其中：</p><ul class="lvl-0"><li class="lvl-2"><p><code>into</code>似乎可以省略，不知道省略之后会不会有什么没发现的限制</p></li><li class="lvl-2"><p>如果是对全部列进行插入的话可以省略（列1，列2，……）这一部分</p></li><li class="lvl-2"><p><code>values</code> 后面每一个括号都代表着一组元组值</p></li><li class="lvl-2"><p><code>insert</code> 的时候是直接在<strong>最后面插入一个新的元组</strong>，若是想要对表中的一个空值添加数据的话建议使用后面用到的<code>update</code></p></li></ul><p>来个实例：</p><p>在 SC 表中一组新值 S7，C1：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">insert</span> SC <span class="keyword">values</span> (<span class="string">&#x27;S7&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/02/data-base-note-4/p1.png" alt="在 SC 表中一组新值 S7，C1"></p><p>由于结果太多，这里就只展示最底下的部分，可以看到这个前后两次的输出结果不同，且没有添加的值会依照默认值设置（通常是null）</p><h2 id="修改数据">修改数据</h2><p>修改数据常用的就是<code>update</code>，这种修改方式通常就是通过与<code>select</code>同原理的条件筛选<code>where</code>来实现，当然，也可以不加where，那样的话就是修改对应属性的全部属性值了</p><p>修改数据的模板为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 属性名<span class="operator">=</span>属性值, 属性名<span class="operator">=</span>属性值 <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>很明显，能看出来这种就是对于<strong>满足where条件的所有元组</strong>进行对应属性值的重新定义</p></li><li class="lvl-2"><p>对数值型的属性值，也可以采用 属性名 = 属性名+1 这种自增式修改，如对S表中所有学生的年龄+1，就可以用 Age=Age+1</p></li><li class="lvl-2"><p>能用<code>where</code>，那对于子查询这些也是没有问题的，可以通过select 选择出对应的值，然后对这个值进行比对或操作，如让所有老师的工资变为最高工资的一半，就可以使用 Sal = (select max(Sal) from T)/2</p></li></ul><p>来个实例：</p><p>把所有老师的工资设置为平均工资的1.2倍</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN, Sal <span class="keyword">from</span> T </span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> Sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">AVG</span>(Sal) <span class="keyword">from</span> T)<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line"><span class="keyword">select</span> TN, Sal <span class="keyword">from</span> T </span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/02/data-base-note-4/p2.png" alt="把所有老师的工资设置为平均工资的1.2倍"></p><h2 id="删除数据">删除数据</h2><p>简单粗暴，直接明了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span>]</span><br></pre></td></tr></table></figure><p>没加<code>where</code>就是删除所有属性值，加了<code>where</code>就是删除满足条件的属性值，注意这个只是删属性值的不是删表的</p><p>实例：</p><p>删除学生表刚刚添加的S7</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC <span class="keyword">where</span> SN <span class="operator">=</span> <span class="string">&#x27;S7&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/06/02/data-base-note-4/p3.png" alt="删除学生表刚刚添加的S7"></p><hr><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;&lt;em&gt;（这一部分已经少到需要做基本介绍来充数了么？）&lt;/em&gt;&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;数据表的操作相比起查询来说不要简单太多，但也是数据库系统管理中不可或缺的一部分，包括增、改、删三大部分，接下来进行逐一讲解&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MYSQL" scheme="https://elementgc.github.io/tags/MYSQL/"/>
    
    <category term="SQL Server Management System" scheme="https://elementgc.github.io/tags/SQL-Server-Management-System/"/>
    
    <category term="SSMS" scheme="https://elementgc.github.io/tags/SSMS/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（3）--数据库的创建与查询</title>
    <link href="https://elementgc.github.io/2023/05/28/data-base-note-3/"/>
    <id>https://elementgc.github.io/2023/05/28/data-base-note-3/</id>
    <published>2023-05-28T06:44:06.000Z</published>
    <updated>2023-06-05T02:02:13.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建、插入、构建一个数据库">创建、插入、构建一个数据库</h2><h3 id="数据库">数据库</h3><p><strong>创建数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名称</span><br></pre></td></tr></table></figure><p><strong>修改数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database 数据库名称</span><br><span class="line"><span class="comment">-- 添加数据文件</span></span><br><span class="line"><span class="keyword">add</span> file(基本文件格式)，</span><br><span class="line"><span class="comment">-- 添加日志文件</span></span><br><span class="line"><span class="keyword">add</span> log file(基本文件格式)</span><br><span class="line"><span class="comment">-- 删除文件</span></span><br><span class="line">remove file</span><br><span class="line"><span class="comment">-- 修改文件</span></span><br><span class="line">modify file(基本文件格式)</span><br><span class="line"><span class="comment">-- 添加文件组</span></span><br><span class="line"><span class="keyword">add</span> filegroup 文件组名</span><br><span class="line"><span class="comment">-- 删除文件组</span></span><br><span class="line">remove filegroup 文件组名</span><br><span class="line"><span class="comment">-- 修改文件组</span></span><br><span class="line">modify filegroup 文件组名</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本文件格式为：</span></span><br><span class="line"><span class="comment">name = 文件名，</span></span><br><span class="line"><span class="comment">filename = &#x27;文件路径&#x27;,</span></span><br><span class="line"><span class="comment">size = 文件大小,</span></span><br><span class="line"><span class="comment">filegrowth = 自动增长容量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数据表—属性与约束">数据表—属性与约束</h3><p><strong>创建数据表，以及各种约束设置介绍</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">列名 列域(数据类型) 其他约束,</span><br><span class="line">列名 列域(数据类型) 其他约束,</span><br><span class="line">    ...</span><br><span class="line">列名 列域(数据类型) 其他约束,</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 书上的例子</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S(</span><br><span class="line">SNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">constraint</span> S_cons <span class="keyword">not</span> <span class="keyword">null</span>,<span class="comment">-- 建立约束约束名为 S_cons，约束内容为“非空”</span></span><br><span class="line">    SN <span class="type">nchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,<span class="comment">-- 这也是建立非空约束，没有约束名</span></span><br><span class="line">    Sex <span class="type">nchar</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span>, <span class="comment">-- 建立约束，设置默认值（缺省值）为男</span></span><br><span class="line">    Age <span class="type">int</span>,</span><br><span class="line">    Dept <span class="type">nchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 唯一约束</span></span><br><span class="line"><span class="comment">-- 单列唯一</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S(</span><br><span class="line">SNo <span class="type">varchar</span>(<span class="number">6</span>),</span><br><span class="line">    SN <span class="type">nchar</span>(<span class="number">10</span>) <span class="keyword">unique</span>,<span class="comment">-- 设置唯一约束</span></span><br><span class="line">    Sex <span class="type">nchar</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    Age <span class="type">int</span>,</span><br><span class="line">    Dept <span class="type">nchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 多列组合唯一</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S(</span><br><span class="line">SNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">unique</span>,<span class="comment">-- 设置唯一约束</span></span><br><span class="line">    SN <span class="type">nchar</span>(<span class="number">10</span>) ,</span><br><span class="line">    Sex <span class="type">nchar</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span>, </span><br><span class="line">    Age <span class="type">int</span>,</span><br><span class="line">    Dept <span class="type">nchar</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">constraint</span> S_uniq <span class="keyword">unique</span>(SNo,SN)<span class="comment">-- 建立多列唯一约束，保证同一姓名的学生不同学号</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主键约束</span></span><br><span class="line"><span class="comment">-- 单列主键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> S(</span><br><span class="line">SNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">primary</span> key,<span class="comment">-- 设为表的主键</span></span><br><span class="line">    SN <span class="type">nchar</span>(<span class="number">10</span>),</span><br><span class="line">    Sex <span class="type">nchar</span>(<span class="number">1</span>),</span><br><span class="line">    Age <span class="type">int</span>,</span><br><span class="line">    Dept <span class="type">nchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 多列主键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">    SNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">CNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    Score <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">constraint</span> SC_prim <span class="keyword">primary</span> key(SNo,CNo)</span><br><span class="line">    )</span><br><span class="line"><span class="comment">-- 外键约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">SNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">constraint</span> S_fore <span class="keyword">foreign</span> key reference S(SNo),<span class="comment">-- 定义外键，这个外键是S表的主键SNo</span></span><br><span class="line">CNo <span class="type">varchar</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">foreign</span> key reference C(CNo),<span class="comment">-- 定义外键，这个外键是C表的主键CNo</span></span><br><span class="line">Score <span class="type">int</span>,</span><br><span class="line"><span class="keyword">constraint</span> SC_prim <span class="keyword">primary</span> key(SNo,CNo)<span class="comment">-- 同时SNo与CNo共同作为SC表的主键</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- check约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(</span><br><span class="line">SNo <span class="type">varchar</span>(<span class="number">6</span>),</span><br><span class="line">CNo <span class="type">varchar</span>(<span class="number">6</span>),</span><br><span class="line">Score <span class="type">int</span> <span class="keyword">check</span> (Score<span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">and</span> Score <span class="operator">&lt;=</span> <span class="number">100</span>)</span><br><span class="line">    <span class="comment">-- 另一种同义的表述方法</span></span><br><span class="line">Score <span class="type">int</span> <span class="keyword">check</span> (Score <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">100</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>修改数据表</strong>–<strong>属性修改</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为数据表添加新的属性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">add</span> </span><br><span class="line">class_No <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- 添加新的完整性约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">add</span> </span><br><span class="line"><span class="keyword">constraint</span> S_Prim <span class="keyword">primary</span> key (SNo)</span><br><span class="line"><span class="comment">-- 修改列域或其他约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">alter</span></span><br><span class="line"><span class="keyword">column</span> SNo <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">/* alter改变列的使用限制</span></span><br><span class="line"><span class="comment">- 不能改变列名</span></span><br><span class="line"><span class="comment">- 不能为含有空值的列添加 not null 约束</span></span><br><span class="line"><span class="comment">- 若该列中存在数据，则不能改变列的数据类型（域）</span></span><br><span class="line"><span class="comment">- 只能修改 not null ，其他的得使用删除+添加约束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 删除完整性约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">drop</span></span><br><span class="line"><span class="keyword">constraint</span> S_Prim<span class="comment">-- 约束名就是这个时候起作用的</span></span><br></pre></td></tr></table></figure><p><strong>删除数据表</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> S</span><br></pre></td></tr></table></figure><h3 id="数据表—元组">数据表—元组</h3><p><strong>按照指定想法添加内容</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (列名<span class="number">1</span>,列名<span class="number">2</span>,...) <span class="keyword">values</span> (值<span class="number">1</span><span class="number">-1</span>,值<span class="number">1</span><span class="number">-2</span>,...),(值<span class="number">2</span><span class="number">-1</span>,值<span class="number">2</span><span class="number">-2</span>,...)</span><br></pre></td></tr></table></figure><p><strong>添加教材内基本内容</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数据来源于教材</span></span><br><span class="line"><span class="keyword">insert</span> T <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;T1&#x27;</span>,<span class="string">&#x27;李力&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">47</span>,<span class="string">&#x27;教授&#x27;</span>,<span class="number">1500</span>,<span class="number">3000</span>,<span class="string">&#x27;计算机&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T2&#x27;</span>,<span class="string">&#x27;王平&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;讲师&#x27;</span>,<span class="number">800</span>,<span class="number">1200</span>,<span class="string">&#x27;信息&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T3&#x27;</span>,<span class="string">&#x27;刘伟&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;讲师&#x27;</span>,<span class="number">900</span>,<span class="number">1200</span>,<span class="string">&#x27;计算机&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T4&#x27;</span>,<span class="string">&#x27;张雪&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">51</span>,<span class="string">&#x27;教授&#x27;</span>,<span class="number">1600</span>,<span class="number">3000</span>,<span class="string">&#x27;自动化&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T5&#x27;</span>,<span class="string">&#x27;张兰&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">39</span>,<span class="string">&#x27;副教授&#x27;</span>,<span class="number">1300</span>,<span class="number">2000</span>,<span class="string">&#x27;信息&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T<span class="comment">-- 删除整个表中的数据（保留表头）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> S <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;S1&#x27;</span>,<span class="string">&#x27;赵亦&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">17</span>,<span class="string">&#x27;计算机&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S2&#x27;</span>,<span class="string">&#x27;钱尔&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;信息&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S3&#x27;</span>,<span class="string">&#x27;孙珊&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;信息&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S4&#x27;</span>,<span class="string">&#x27;李思&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;自动化&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S5&#x27;</span>,<span class="string">&#x27;周武&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;计算机&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;S6&#x27;</span>,<span class="string">&#x27;吴丽&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;自动化&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> S</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> C <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;C1&#x27;</span>,<span class="string">&#x27;程序设计&#x27;</span>,<span class="number">60</span>),</span><br><span class="line">(<span class="string">&#x27;C2&#x27;</span>,<span class="string">&#x27;微机原理&#x27;</span>,<span class="number">80</span>),</span><br><span class="line">(<span class="string">&#x27;C3&#x27;</span>,<span class="string">&#x27;数字逻辑&#x27;</span>,<span class="number">60</span>),</span><br><span class="line">(<span class="string">&#x27;C4&#x27;</span>,<span class="string">&#x27;数据结构&#x27;</span>,<span class="number">80</span>),</span><br><span class="line">(<span class="string">&#x27;C5&#x27;</span>,<span class="string">&#x27;数据库&#x27;</span>,<span class="number">60</span>),</span><br><span class="line">(<span class="string">&#x27;C6&#x27;</span>,<span class="string">&#x27;编译原理&#x27;</span>,<span class="number">60</span>),</span><br><span class="line">(<span class="string">&#x27;C7&#x27;</span>,<span class="string">&#x27;操作系统&#x27;</span>,<span class="number">60</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> C</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> SC <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;S1&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>,<span class="number">90</span>),</span><br><span class="line">(<span class="string">&#x27;S1&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>,<span class="number">85</span>),</span><br><span class="line">(<span class="string">&#x27;S2&#x27;</span>,<span class="string">&#x27;C5&#x27;</span>,<span class="number">57</span>),</span><br><span class="line">(<span class="string">&#x27;S2&#x27;</span>,<span class="string">&#x27;C6&#x27;</span>,<span class="number">80</span>),</span><br><span class="line">(<span class="string">&#x27;S2&#x27;</span>,<span class="string">&#x27;C7&#x27;</span>,<span class="keyword">null</span>),</span><br><span class="line">(<span class="string">&#x27;S2&#x27;</span>,<span class="string">&#x27;C4&#x27;</span>,<span class="number">70</span>),</span><br><span class="line">(<span class="string">&#x27;S3&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>,<span class="number">75</span>),</span><br><span class="line">(<span class="string">&#x27;S3&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>,<span class="number">70</span>),</span><br><span class="line">(<span class="string">&#x27;S3&#x27;</span>,<span class="string">&#x27;C4&#x27;</span>,<span class="number">85</span>),</span><br><span class="line">(<span class="string">&#x27;S4&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>,<span class="number">93</span>),</span><br><span class="line">(<span class="string">&#x27;S4&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>,<span class="number">85</span>),</span><br><span class="line">(<span class="string">&#x27;S4&#x27;</span>,<span class="string">&#x27;C3&#x27;</span>,<span class="number">83</span>),</span><br><span class="line">(<span class="string">&#x27;S5&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>,<span class="number">89</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SC</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> TC <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;T1&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T1&#x27;</span>,<span class="string">&#x27;C4&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T2&#x27;</span>,<span class="string">&#x27;C5&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T2&#x27;</span>,<span class="string">&#x27;C6&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T3&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T3&#x27;</span>,<span class="string">&#x27;C5&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T4&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T4&#x27;</span>,<span class="string">&#x27;C3&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T5&#x27;</span>,<span class="string">&#x27;C5&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;T5&#x27;</span>,<span class="string">&#x27;C7&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> TC</span><br></pre></td></tr></table></figure><p><strong>修改数据表中的数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改单个数据</span></span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> Dept<span class="operator">=</span><span class="string">&#x27;信息&#x27;</span> <span class="keyword">where</span> TN<span class="operator">=</span><span class="string">&#x27;刘伟&#x27;</span> <span class="comment">-- 将刘伟老师的所在院系修改为“信息”</span></span><br><span class="line"><span class="comment">-- 修改某属性的批量属性值</span></span><br><span class="line"><span class="keyword">update</span> S <span class="keyword">set</span> Age<span class="operator">=</span>Age<span class="operator">+</span><span class="number">1</span><span class="comment">-- 学生年龄全部+1</span></span><br><span class="line"><span class="comment">-- 当然也可以后面+where添加约束</span></span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> Sal <span class="operator">=</span> <span class="number">1.2</span><span class="operator">*</span>Sal <span class="keyword">where</span> (Prof<span class="operator">=</span><span class="string">&#x27;讲师&#x27;</span>)<span class="keyword">and</span>(Sal<span class="operator">&lt;</span><span class="number">1000</span>)<span class="comment">-- 给工资低于1k的讲师涨工资</span></span><br><span class="line"><span class="comment">-- 也可以使用子查询提供需要修改的值</span></span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> Sal <span class="operator">=</span> (<span class="keyword">select</span> <span class="number">1.2</span><span class="operator">*</span><span class="built_in">AVG</span>(Sal)<span class="keyword">from</span> T)<span class="comment">-- 所有老师的工资提高到平均工资的1.2倍</span></span><br></pre></td></tr></table></figure><p><strong>删除数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除单个属性值</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T <span class="keyword">where</span> TN<span class="operator">=</span><span class="string">&#x27;刘伟&#x27;</span></span><br><span class="line"><span class="comment">-- 全删了</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T</span><br></pre></td></tr></table></figure><hr><h2 id="查询">查询</h2><p><strong>查询语句的完整结构</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名[<span class="keyword">as</span> 别名][,列名<span class="number">2</span>,[<span class="keyword">as</span> 别名<span class="number">2</span>]] <span class="keyword">from</span> 表名[<span class="keyword">as</span> 别名] <span class="comment">-- 无条件查询</span></span><br><span class="line">[<span class="keyword">where</span> 检索条件]<span class="comment">-- 有条件检索</span></span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> 列名 [<span class="keyword">having</span> 条件表达式]]<span class="comment">-- 分组，若有having则只输出满足having的元组</span></span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> 列名 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]]<span class="comment">-- 排序，按照列名的值进行排序，后面跟 升序|降序 ，不填默认升序</span></span><br></pre></td></tr></table></figure><p>查询是数据库进行数据展示时常用的方法，通过各种查询展现出符号需要的数据信息</p><h3 id="无条件查询"><strong>无条件查询</strong></h3><ol><li class="lvl-3"><p>查询全体学生的<strong>学号、姓名和年龄</strong></p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo <span class="keyword">as</span> 学号, SN <span class="keyword">as</span> 姓名, Age <span class="keyword">as</span> 年龄 <span class="keyword">from</span> S</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p1.png" alt="查询全体学生的学号、姓名和年龄"></p><ol start="2"><li class="lvl-3"><p>查询全体学生的<strong>所有信息</strong></p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> S</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p2.png" alt="查询全体学生所有信息"></p><hr><h3 id="条件查询"><strong>条件查询</strong></h3><p>条件查询主要特征就是后面加了个<code>where</code>引导的检索条件，检索条件通常由<strong>列名</strong>、<strong>比较运算符</strong>、<strong>属性值</strong>三个部分组成，常用的比较运算符如下</p><table bgcolor="white">    <tr align="center">        <th>运算符</th>        <th>含义</th>    </tr>    <tr align="center">        <td>"="  ">"  "<" ">="  "<=" "!=" " <>" </="></"></td><td>比较大小</td>    </tr>    <tr align="center">        <td>and, or, not</td><td>多条件复合</td>    </tr>    <tr align="center">        <td>between and</td>        <td>确定范围</td>    </tr>    <tr align="center">        <td>in</td>        <td>确定集合</td>    </tr>    <tr align="center">        <td>like</td>        <td>匹配字符（就看你有没有这个字符）</td>    </tr>    <tr align="center">        <td>is null</td>        <td>为空</td>    </tr></table><h4 id="比较大小条件"><strong>比较大小条件</strong></h4><p>查询成绩高于85分的学生的学号、课程号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo <span class="keyword">as</span> 学号, CNo <span class="keyword">as</span> 课程号, Score <span class="keyword">as</span> 成绩 <span class="keyword">from</span> SC <span class="keyword">where</span> Score<span class="operator">&gt;</span><span class="number">85</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p3.png" alt="查询成绩高于85分的学生的学号、课程号和成绩"></p><h4 id="多重条件查询"><strong>多重条件查询</strong></h4><p>查询工资大于1000的男老师的教师号、姓名和职称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TNo <span class="keyword">as</span> 教师号, TN <span class="keyword">as</span> 姓名, Prof <span class="keyword">as</span> 职称 <span class="keyword">from</span> T <span class="keyword">where</span> Sal<span class="operator">&gt;</span><span class="number">1000</span> <span class="keyword">and</span> Sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p4.png" alt="查询工资大于1000的男老师的教师号、姓名和职称"></p><h4 id="范围查询"><strong>范围查询</strong></h4><p>查询工资在1000~1500的老师的教师号、姓名和职称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TNo <span class="keyword">as</span> 教师号, TN <span class="keyword">as</span> 姓名, Prof <span class="keyword">as</span> 职称 <span class="keyword">from</span> T <span class="keyword">where</span> Sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">1500</span><span class="comment">--  1000&lt;=Sal&lt;=1500</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p5.png" alt="查询工资在1000~1500的老师的教师号、姓名和职称"></p><h4 id="集合查询in"><strong>集合查询</strong>in</h4><p>查询选修了C1<strong>或</strong>C2的学生的学号、课程号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo <span class="keyword">as</span> 学号, CNo <span class="keyword">as</span> 课程号, Score <span class="keyword">as</span> 成绩 <span class="keyword">from</span> SC <span class="keyword">where</span> CNo <span class="keyword">in</span>(<span class="string">&#x27;C1&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p6.png" alt="查询选修了C1或C2的学生的学号、课程号和成绩"></p><h4 id="集合查询not-in"><strong>集合查询</strong>not in</h4><p>查询既没有选C1，也没有选C2的学生的学号、课程号和成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo <span class="keyword">as</span> 学号, CNo <span class="keyword">as</span> 课程号, Score <span class="keyword">as</span> 成绩 <span class="keyword">from</span> SC <span class="keyword">where</span> CNo <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;C1&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p7.png" alt="查询既没有选C1，也没有选C2的学生的学号、课程号和成绩"></p><blockquote><p>可以看出，S3与S4其实也选了C1和C2，说明这个查询方法只是筛选课程号而已，并没有真正达到要求，要真正做到匹配课程号和学生，可以通过子查询</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo <span class="keyword">as</span> 学号, CNo <span class="keyword">as</span> 课程号, Score <span class="keyword">as</span> 成绩 <span class="keyword">from</span> SC <span class="keyword">where</span> SNo <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> SNo <span class="keyword">from</span> SC <span class="keyword">where</span> CNo <span class="keyword">in</span>(<span class="string">&#x27;C1&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p8.png" alt="真-查询既没有选C1，也没有选C2的学生的学号、课程号和成绩"></p><h4 id="部分匹配查询"><strong>部分匹配查询</strong></h4><p>查询姓名中第二个字是“力”字的老师姓名和教师号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN <span class="keyword">as</span> 姓名, TNo <span class="keyword">as</span> 教师号 <span class="keyword">from</span> T <span class="keyword">where</span> TN <span class="keyword">like</span> <span class="string">&#x27;_力%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p9.png" alt="查询姓名中第二个字是“力”字的老师姓名和教师号"></p><ul class="lvl-0"><li class="lvl-2"><p>部分匹配查询所使用的的通配符</p></li></ul><table bgcolor="white">    <tr align="center">        <th width="10%">通配符</th>        <th width="40%">功能</th>        <th width="50%">实例</th>    </tr>    <tr align="center">        <td>%</td>        <td>代表0个或多个字符，即不确定字符数</td>        <td>"ab%"表示<b>任何开头</b>为ab的任意字符串 <br>            "%ab%"表示<b>包含</b>"ab"的任意字符串        </td>    </tr>    <tr align="center">        <td>_</td>        <td>代表且仅代表一个字符</td>        <td>"_b_"表示三字符组成的字符串，且第二个字符为b</td>    </tr>    <tr align="center">        <td>[]</td>        <td>代表在某一范围内的字符（通常是数字），<b>与上面两个结合使用</b></td>        <td>[0-9]说明对应的字符在0~9这个之间,没错，中间那个就是减号'-'</td>    </tr>    <tr align="center">        <td>[^]</td>        <td>代表不在某一范围内的字符（通常是数字），<b>与上面两个结合使用</b></td>        <td>[^0-9]说明对应的字符不在0~9这个之间</td>    </tr><tr>        <td colspan="3">注意：使用like后面跟的通配符表示的是字符与字符串，不能用[]和[]来对数值型的属性值进行条件检索</td>    </tr></table>#### **分组查询**<p>分组查询常常和聚集函数（库函数）结合使用，因此在使用分组查询之前，我们再来了解一下<strong>库函数</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>AVG：返回一个列的平均值</p></li><li class="lvl-2"><p>SUM：返回一个列计算值的总和</p></li><li class="lvl-2"><p>MAX：返回一个列的最大值</p></li><li class="lvl-2"><p>MIN：返回一个列的最小值</p></li><li class="lvl-2"><p>COUNT：返回根据一个列的各种数值统计的个数</p><ul class="lvl-2"><li class="lvl-4">值为0的也会计算在内，值为空（null）才不会被计入</li><li class="lvl-4">若想要去掉重复的数值，即只使用count统计某个属性的值有多少种，可以使用<code>count(distinct 列名)</code></li><li class="lvl-4">若使用count(*)，则是统计整个表的元组个数，不允许使用distinct去重——关系中也不允许有重复的元组</li></ul></li></ul><p><strong>分组查询</strong>，查询每个老师的教师号以及他们任课的数量</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TNo, <span class="built_in">count</span>(<span class="operator">*</span>)<span class="keyword">as</span> 任课数量 <span class="keyword">from</span> TC <span class="keyword">group</span> <span class="keyword">by</span> TNo</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p10.png" alt="查询每个老师的教师号以及他们任课的数量"></p><p>分组查询+<strong>having</strong>条件，查询选修两门以上（包括两门）课程的学生的学号和选课门数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo, <span class="built_in">COUNT</span>(CNo) <span class="keyword">as</span> 选课门数 <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> SNo <span class="keyword">having</span> (<span class="built_in">COUNT</span>(CNo)<span class="operator">&gt;=</span><span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p11.png" alt="查询选修两门以上（包括两门）课程的学生的学号和选课门数"></p><h4 id="查询结果排序">查询结果排序</h4><p>查询没有选修C1的学生的学号、成绩，按照成绩降序排序</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SNo, Score <span class="keyword">from</span> SC <span class="keyword">where</span> SNo <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> SNo <span class="keyword">from</span> SC <span class="keyword">where</span> CNo<span class="operator">=</span><span class="string">&#x27;C1&#x27;</span>) <span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p12.png" alt="查询没有选修C1的学生的学号、成绩，按照成绩降序排序"></p><hr><h3 id="多关系表的连接查询">多关系表的连接查询</h3><h4 id="内连接">内连接</h4><p>默认的连接操作，一般使用如<code>select xx from TA, TB where (TA.x ? TB.x) </code>这类的查询方式时，就是默认的内连接查询，即将 TA 表与 TB 表进行连接，示例如下：</p><blockquote><p>注意，where后面的条件必须添加，不然会直接把TA的所有元组和TB的所有元组进行m<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span>n的组合，即笛卡尔积，这个时候就不是内连接，而是<strong>交叉连接</strong></p></blockquote><p>查询所有选课学生的学号、姓名、选课名称和成绩——用到了学生表S、学生课程表SC、课程表C</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.SNo <span class="keyword">as</span> 学号, S.SN <span class="keyword">as</span> 姓名, c.CN <span class="keyword">as</span> 课程名, sc.Score <span class="keyword">as</span> 成绩  <span class="keyword">from</span> S <span class="keyword">as</span> s, SC <span class="keyword">as</span> sc, C <span class="keyword">as</span> c <span class="keyword">where</span> (s.SNo <span class="operator">=</span> sc.SNo <span class="keyword">and</span> sc.CNo <span class="operator">=</span> c.CNo)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p13.png" alt="内连接--查询所有选课学生的学号、姓名、选课名称和成绩"></p><blockquote><p>从上图可以看出，由于学号为S6的吴丽在SC表上没有匹配的数据，结果展示中就没有她的信息</p></blockquote><h4 id="外连接">外连接</h4><p>与内连接最明显的不同之处就是<strong>参与链接的表有主从之分</strong>，所有展示的数据均以主表的为准，不符合筛选的条件项就直接填空，如同样是上面的要求，使用外连接：</p><p>查询所有选课学生的学号、姓名、选课名称和成绩——用到了学生表S、学生课程表SC、课程表C</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.SNo <span class="keyword">as</span> 学号, S.SN <span class="keyword">as</span> 姓名, c.CN <span class="keyword">as</span> 课程名, sc.Score <span class="keyword">as</span> 成绩  <span class="keyword">from</span> S <span class="keyword">as</span> s <span class="keyword">left</span> <span class="keyword">join</span> SC <span class="keyword">as</span> sc <span class="keyword">on</span> (s.SNo <span class="operator">=</span> sc.SNo) <span class="keyword">left</span> <span class="keyword">join</span> C <span class="keyword">as</span> c <span class="keyword">on</span> (c.CNo <span class="operator">=</span> sc.CNo)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p14.png" alt="外左连接--查询所有选课学生的学号、姓名、选课名称和成绩"></p><p>这里使用的是外连接中的左连接，即以<strong>左边的表为主表</strong>，右边的表为从表。可以看到，使用外连接后学号S6的吴丽同学的信息就展示出来了，但由于其在SC表与C表中没有对应的对应的信息，故对应的信息均为空</p><h4 id="交叉查询">交叉查询</h4><p>简而言之就是没有where的内连接   <em>存疑</em>  ，使用方法为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> S ,C</span><br></pre></td></tr></table></figure><p>结果很长且很离谱，想看的可以试试</p><h4 id="自连接">自连接</h4><p>即一个表与自己进行连接，通常是在需要比较自身各个元组之间的差异，或是提取出某个（或某些）特殊项的时候使用，如：</p><p>检索所有包括S1在内的所有成绩比S1好的同学以及他们的科目、成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.SNo, S.SN, C.CN, SC.Score </span><br><span class="line"><span class="keyword">from</span> SC, S, C, (<span class="keyword">select</span> CNo,Score <span class="keyword">from</span> SC <span class="keyword">where</span> SNo <span class="operator">=</span> <span class="string">&#x27;S1&#x27;</span>) <span class="keyword">as</span> a </span><br><span class="line"><span class="keyword">where</span> (SC.CNo <span class="operator">=</span> a.CNo) <span class="keyword">and</span>  (SC.Score <span class="operator">&gt;=</span> a.Score) <span class="keyword">and</span> (S.SNo<span class="operator">=</span>SC.SNo) <span class="keyword">and</span> (C.CNo <span class="operator">=</span> SC.CNo) </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> SC.Score</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p15.png" alt="所有包括S1在内的所有成绩比S1好的同学以及他们的科目、成绩"></p><p>虽然上面这个代码看着挺复杂的，但其实就是自连接的主要部分就是<code>from SC, S, C, (select CNo,Score from SC where SNo = 'S1') as a </code>里面的<code>select</code>部分而已主要功能就是对比表内比S1成绩更高的学生以及他的分数这些而已</p><hr><h3 id="子查询">子查询</h3><p>子查询与自连接查询类似，不过自连接是在本该出现表的地方弄一个查询结果作为新表；而子查询是在条件判断的时候将查询结果作为条件判断的值，</p><h4 id="普通子查询">普通子查询</h4><p>当子查询所用到条件来自于任一关系表（可以是主表，但<strong>不是直接调用父表属性值</strong>），所用的子查询就成为普通子查询，例如：</p><p><strong>查询结果只有一个返回值时：</strong></p><p>查询与刘伟老师职称相同的老师的教师号与姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN,TNo <span class="keyword">from</span> T <span class="keyword">where</span> Prof <span class="operator">=</span> (<span class="keyword">select</span> Prof <span class="keyword">from</span> T <span class="keyword">where</span> TN <span class="operator">=</span> <span class="string">&#x27;刘伟&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p16.png" alt="查询与刘伟老师职称相同的老师的教师号与姓名"></p><p><strong>查询结果是一组返回值时</strong>：</p><p>我们需要用到关键词<code>any\in</code>或<code>all</code>，</p><ul class="lvl-0"><li class="lvl-2"><p>any\in 的使用：</p><p>any\in使用时表示满足返回值中的任意一个即可，如：</p><p>查询在其他系中工资比计算机系任一老师高的所有老师的名字及其工资</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN <span class="keyword">as</span> 姓名, Sal <span class="keyword">as</span> 薪资 <span class="keyword">from</span> T </span><br><span class="line"><span class="keyword">where</span> (Sal <span class="operator">&gt;</span> <span class="keyword">any</span>(<span class="keyword">select</span> Sal <span class="keyword">from</span> T <span class="keyword">where</span> Dept <span class="operator">=</span> <span class="string">&#x27;计算机&#x27;</span>) <span class="keyword">and</span> Dept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;计算机&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p17.png" alt="查询在其他系中工资比计算机系任一老师高的所有老师的名字及其工资"></p><p><code>in</code> 能够表示 <code>=any</code>这一个整体概念，即与返回值集合中任意一个相等即满足条件，如：</p><p>查询授课课程号为C5的老师的名字</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN <span class="keyword">as</span> 姓名 <span class="keyword">from</span> T <span class="keyword">where</span> TNo <span class="keyword">in</span>( <span class="keyword">select</span> TNo <span class="keyword">from</span> TC <span class="keyword">where</span> CNo <span class="operator">=</span> <span class="string">&#x27;C5&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>all的使用</p><p>all 在使用时表示需要满足所有的返回值才能满足条件，通常只用在数值比较上，即大于所有返回值中的最大值或小于所有返回值中的最小值，例如：</p><p>查询在其他系中工资比计算机系所有老师高的所有老师的名字及其工资</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN <span class="keyword">as</span> 姓名, Sal <span class="keyword">as</span> 薪资 <span class="keyword">from</span> T </span><br><span class="line"><span class="keyword">where</span> (Sal <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> Sal <span class="keyword">from</span> T <span class="keyword">where</span> Dept <span class="operator">=</span> <span class="string">&#x27;计算机&#x27;</span>) <span class="keyword">and</span> Dept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;计算机&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p18.png" alt="查询在其他系中工资比计算机系所有老师高的所有老师的名字及其工资"></p></li></ul><h4 id="相关子查询">相关子查询</h4><p>与普通子查询相对的，相关子查询调用了父关系的属性值，让父关系也经历一次相关子查询中的查询条件的筛选，例如下面这个：</p><p>查询教授C5这门课的老师的姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN <span class="keyword">from</span> T <span class="keyword">where</span> (<span class="string">&#x27;C5&#x27;</span> <span class="keyword">in</span> (<span class="keyword">select</span> CNo <span class="keyword">from</span> TC <span class="keyword">where</span> TNo <span class="operator">=</span> T.TNo))</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p19.png" alt="查询教授C5这门课的老师的姓名"></p><p>根据查询的运行顺序，判断出where中的结果为真时，反过来对照到对应的TC表中的TNo，然后这个TNo又与T表里面的TNo相等，最终完成对T表中TNo的筛选，展示出符合条件的TN</p><p>这可能有点绕，让我们用第二种方法<code>exist</code>来表示相关子查询就更为清楚了，还是查询教授C5这门课的老师的姓名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> TN <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> TC <span class="keyword">where</span> TNo <span class="operator">=</span> T.TNo <span class="keyword">and</span> CNo <span class="operator">=</span><span class="string">&#x27;C5&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个的结果与上面的一样，而且能够看到，我们是通过引用父关系的属性T.TNo=(TC.)TNo来找到满足 CNo=‘C5’  的老师</p><h3 id="其他类型的查询">其他类型的查询</h3><h4 id="集合运算查询">集合运算查询</h4><p>对于<strong>关系模式相同</strong>的不同查询结果，我们可以使用<code>union</code>操作来将两个<strong>查询结果进行合并</strong>，同时也会剔除重复项，例如：</p><p>分别查询出SC表中的S1同学与S5同学的姓名与总分，并合并</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SN <span class="keyword">as</span> 姓名, <span class="built_in">sum</span>(SC.Score) <span class="keyword">as</span> 总分 <span class="keyword">from</span> S,SC <span class="keyword">where</span> (SC.SNo <span class="operator">=</span> <span class="string">&#x27;S1&#x27;</span> <span class="keyword">and</span> S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> S.SN</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> SN <span class="keyword">as</span> 姓名, <span class="built_in">sum</span>(SC.Score) <span class="keyword">as</span> 总分 <span class="keyword">from</span> S,SC <span class="keyword">where</span> (SC.SNo <span class="operator">=</span> <span class="string">&#x27;S5&#x27;</span> <span class="keyword">and</span> S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> S.SN</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p20.png" alt="分别查询出SC表中的S1同学与S5同学的姓名与总分，并合并"></p><h4 id="将查询结果存储到新表">将查询结果存储到新表</h4><p>顾名思义，通过<code>select xx into zz from yy ....</code>来将最终的查询结果存储到新表中例如</p><p>查询所有同学的姓名与总分，将其存储到Score表中</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SN <span class="keyword">as</span> 姓名, <span class="built_in">sum</span>(SC.Score) <span class="keyword">as</span> 总分 <span class="keyword">into</span> Score <span class="keyword">from</span> S,SC <span class="keyword">where</span> (S.SNo <span class="operator">=</span> SC.SNo) <span class="keyword">group</span> <span class="keyword">by</span> S.SN </span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p21.png" alt="查询并存储"></p><p><img src="https://elementgc.github.io/2023/05/28/data-base-note-3/p22.png" alt="结果"></p><hr><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建、插入、构建一个数据库&quot;&gt;创建、插入、构建一个数据库&lt;/h2&gt;
&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建数据库&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MYSQL" scheme="https://elementgc.github.io/tags/MYSQL/"/>
    
    <category term="SQL Server Management System" scheme="https://elementgc.github.io/tags/SQL-Server-Management-System/"/>
    
    <category term="SSMS" scheme="https://elementgc.github.io/tags/SSMS/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（2）--关系模型与关系代数</title>
    <link href="https://elementgc.github.io/2023/05/27/data-base-note-2/"/>
    <id>https://elementgc.github.io/2023/05/27/data-base-note-2/</id>
    <published>2023-05-27T12:08:14.000Z</published>
    <updated>2023-06-04T09:30:27.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系模型的基本概念">关系模型的基本概念</h2><h3 id="关系实例">关系实例</h3><p>是由命名的若干列和行组成的<strong>表格</strong>，其中每一列称为<strong>属性</strong>，每一行称为元组，关系实例中的数据称为<strong>基数</strong></p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p1.png" alt="关系实例" width="450" height="250"></p><h3 id="关系模式">关系模式</h3><p>关系模式一般具备以下要素：</p><ul class="lvl-0"><li class="lvl-2"><p>关系名：关系实例的名称，<strong>在数据库中必须唯一</strong></p></li><li class="lvl-2"><p>关系中属性的名字以及相关联的域</p></li><li class="lvl-2"><p>完整性约束：数据的相关形式规则</p></li></ul><blockquote><p>一般，可以将关系模式的框架可以表示为：</p><p>关系名（属性1，属性2，……，属性n）</p></blockquote><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p2.png" alt="关系模式" width="450" height="250"></p><h3 id="关系数据库">关系数据库</h3><p>关系数据库是一个集合的概念，从不同的角度看就有不同的含义</p><ul class="lvl-0"><li class="lvl-2"><p>关系数据库 = 关系实例的集合 = “关系实例 s”</p></li><li class="lvl-2"><p>关系数据库 = 关系模式的集合 = “关系模式 s”</p></li><li class="lvl-2"><p>关系数据库 = “实体+联系 s”</p></li></ul><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p3.png" alt="关系数据库" width="450" height="250"></p><h3 id="关系">关系</h3><p>关系 = 关系模式 + 关系实例，即一个二维表格，具有如下三个性质：</p><ul class="lvl-0"><li class="lvl-2"><p>每个关系都有唯一的一个关系名</p></li><li class="lvl-2"><p>关系表中的每一列都是<strong>不可再分</strong>的基本属性，并且互不重名</p></li><li class="lvl-2"><p>表中的行列次序不重要，即除了表头外，每一行、每一列都可以相互交换</p></li></ul><p>结合上面两个所包含的元素进行分析，我们也可以得到关系所具备的元素</p><ul class="lvl-0"><li class="lvl-2"><p>元组，即表中的一行，表示一个实体。关系是由一个个元组组成的</p></li><li class="lvl-2"><p>属性，即表中的一列，每个属性都有一个属性名， 属性值就是各个元组属性的取值</p></li><li class="lvl-2"><p>域，属性的取值范围，同一属性只能在相同的域中取值，通常由数据类型、长度、精度等组成</p></li><li class="lvl-2"><p>度，也称为目，表示属性的个数</p></li><li class="lvl-2"><p>分量，表示元组中的一个属性值，即表格中一个单元格中的数值</p></li><li class="lvl-2"><p>键，也称为<strong>关键字</strong>或<strong>码</strong>，关系中能够<strong>唯一区分</strong>不同元组的<strong>属性或属性组</strong>（有时候不止一个属性，要多个属性相结合），键的属性值必须<strong>唯一</strong>，即不能重复，且<strong>不能为空</strong></p><ul class="lvl-2"><li class="lvl-4">候选键（Candidate Key），能够在一个关系中唯一区分不同元组的属性或属性组</li><li class="lvl-4">主属性（Primary Attribute），包含在候选键中的属性，反之称为非主属性</li><li class="lvl-4">全码（All Key），一个关系中没有非主属性，即都是候选键</li><li class="lvl-4">主键（Primary Key），若是候选键不唯一，则需要从中选出一个作为关系的主键，且<strong>每个关系中有且只有一个主键</strong>，主键不具有地位差异，仅仅只是一个标识，让处理数据的时候能够方便些</li><li class="lvl-4">外键 （Foreign Key），现有两个关系T1与T2，T1的主键为P1，T2的主键为P2，若P2同时也是T1中的一个属性（不一定得是候选键），则称<strong>P2是T1的外键</strong>，此时T1称为<strong>参照关系</strong>，T2称为<strong>被参照关系</strong></li></ul><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p4.png" alt="外键参照图" width="450" height="250"></p></li></ul><hr><h2 id="关系模式的数据结构">关系模式的数据结构</h2><h3 id="关系的类型">关系的类型</h3><p>关系有三种基本类型，分别为：基本表，查询表，视图表</p><ul class="lvl-0"><li class="lvl-2"><p>基本表又称基本关系，是实际存在的表，是实际存储在数据的中的数据的逻辑表示</p></li><li class="lvl-2"><p>查询表是添加查询的条件与内容后，对应结果的表</p></li><li class="lvl-2"><p>视图表是由基本表或其他视图导出的表，是虚表，不对应实际存储的数据</p></li></ul><h3 id="关系的性质">关系的性质</h3><ol><li class="lvl-3"><p>每个列的分量必须来自同一个域，不许是同一类型的数据（即每一列都是同一个属性）</p></li><li class="lvl-3"><p>不同列的取值范围可以来自同一个域（即多个属性可以使用同一个域）</p></li><li class="lvl-3"><p>列的顺序可以任意交换，无论域是否相同（交换列的同时也要交换属性名-即表头）</p></li><li class="lvl-3"><p>关系中的元组的顺序可以任意交换（即每一行的数据都是独立的，上下交换没问题）</p></li><li class="lvl-3"><p>关系中不允许出现相同的元组（这就是为什么输数据的时候得一行一行的输）</p></li><li class="lvl-3"><p>关系中的每一分两必须是不可分割的数据项，即每个属性<strong>不可再分</strong>（表头占两行）（出生年月能不能被分成出生年+出生月这种，不属于再分的情况）</p></li></ol><h3 id="关系模式-2">关系模式</h3><p>关系模式是一个五元组，形式化定义为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></span></p><p>其中</p><table bgcolor="white">    <tr>        <td width="100px">R:</td>          <td>关系名</td>    </tr>      <tr>        <td>U</td>          <td>组成该关系的属性名集合，一般为（A1,A2,……,An）</td>    </tr>      <tr>        <td>D:</td>          <td>属性组U中属性所来自的域</td>    </tr>  <tr>        <td>DOM:</td>          <td>属性向域的映像集合</td>  </tr>      <tr>        <td>F:</td>          <td>属性间数据的依赖关系集合</td>  </tr>  </table><p>但通常情况下，我们将其简化为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mspace width="1em"><mi>O</mi><mi>R</mi><mspace width="1em"><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mspace></mspace></mrow><annotation encoding="application/x-tex">R(A_1,A_2,...,A_n)\quad OR\quad R(U)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">OR</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">)</span></span></span></span></span></p><h3 id="关系数据库模式">关系数据库模式</h3><p>即关系模式的集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>R</mi><mi>m</mi></msub></mrow></mrow><annotation encoding="application/x-tex">S = {R_1,R_2,...R_m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>  和完整性约束的集合IC</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p5.png" alt="关系数据库模式" width="450" height="250"></p><hr><h2 id="关系模型的数据操作">关系模型的数据操作</h2><h3 id="关系操作的基本内容">关系操作的基本内容</h3><ul class="lvl-0"><li class="lvl-2"><p>数据查询：数据检索，统计，排序，分组以及用户对信息的需求等功能（通常是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">select</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span></span></span></span>语句）</p></li><li class="lvl-2"><p>数据维护：数据增加，删除，修改等数据自身更新的功能（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mo separator="true">,</mo><mi>d</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>e</mi><mo separator="true">,</mo><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">insert,drop,delete,update</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.02778em;">ser</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span>等语句）</p></li><li class="lvl-2"><p>数据控制：为了保证数据的<strong>安全性和完整性</strong>而采用的数据<strong>存取控制及并发控制</strong>等功能</p></li></ul><h3 id="基本的关系操作">基本的关系操作</h3><h4 id="查询操作">查询操作</h4><p>查询操作是关系操作中最重要的部分，通过各种命令方法可实现：选择、连接、投影、并</p><p>差、除、交、笛卡尔积等，其中<strong>选择、投影、并、差、笛卡尔积</strong>是五种基本操作</p><h4 id="更新操作">更新操作</h4><p>更新操作主要就是对数据库中的数据进行增、删、改等常规操作，相较于查询操作更为直接</p><h3 id="关系操作的特点">关系操作的特点</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>关系操作语言操作一体化</strong><br>数据定义、查询、更新、控制一体化，可以作为诉诸语言嵌入到主语言中，也可以自身作为一种语言交互使用</p></li><li class="lvl-2"><p><strong>关系操作是一次一集合的方式（set-at-a-time）</strong><br>因为各种操作都是对关系表一整个地进行，所以操作的对象或者结果都是以集合的形式进行的</p></li><li class="lvl-2"><p><strong>关系操作语言是高度非过程化的语言</strong><br>关系操作具有强大的表达能力，用户使用关系语言时，只需要指出做什么，而不用指出怎么做，诸如路径的选择、数据操作方法以及优化都由<strong>数据库管理系统（DBMS）自动完成</strong></p></li></ul><h4 id="关系操作的查询语言">关系操作的查询语言</h4><p>早期的关系操作能力通常用代数方式（关系代数）或逻辑方式（关系演算<sup>*</sup>）来实现的：</p><ul class="lvl-0"><li class="lvl-2"><p>关系代数是用<strong>关系的运算</strong>来表达查询要求</p></li><li class="lvl-2"><p>关系演算使用为此来表达查询要求</p></li><li class="lvl-2"><p>关系代数、元组关系演算和域关系演算三种语言在表达能力上完全等价，都是抽象的查询语言</p></li></ul><h3 id="关系模型数据操作的重要特征">关系模型数据操作的重要特征</h3><ul class="lvl-0"><li class="lvl-2"><p>关系模型操作的对象是<strong>集合</strong>而不是行</p><p>也就是说操作的数据及操作的结果是<strong>完整的的表</strong>，所包含的内容是行的集合。因此，<strong>几何处理能力</strong>是关系系统区别于其他系统的一个重要特征</p></li></ul><h2 id="关系模型的数据约束">关系模型的数据约束</h2><h3 id="数据约束">数据约束</h3><p>为了防止不符合规范的数据进入数据库，在用户对数据库进行操作（DML）时，DBMS自动按照一定的约束条件对数据进行检测，是不符合约束的数据不能进入数据库，以确保数据库中的数据相对正确、有效、相容；</p><p>关系模型中的数据库主要分为以下四类：</p><ul class="lvl-0"><li class="lvl-2"><p>固有约束</p><p>数据模型中本来就设计好的约束，比如一个<strong>关系中不能有重复的元组</strong>，这类约束一开始就是被定义好的，不需要特别去定义</p></li><li class="lvl-2"><p>完整性约束</p><p>可以在数据模型的模式中直接表示的约束</p></li><li class="lvl-2"><p>触发器约束</p><p>约束条件比较复杂，不能在数据模型的模式中直接表示的约束，必须由相应的应用程序表示和执行</p></li><li class="lvl-2"><p>数据依赖</p><p>包括函数依赖和多值依赖，用来检测数据库设计的好坏，在数据规范化的时候能够用得上</p></li></ul><h3 id="完整性约束">完整性约束</h3><p>完整性约束主要有三种：<strong>实体完整性，参照完整性和用户自定义的完整性</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>实体完整性和参照完整性</strong>是关系模型中必须满足的完整性约束条件，任何关系数据库都应该满足这两类完整性，称为<strong>关系的两个不变形性</strong></p></li><li class="lvl-2"><p><strong>用户定义完整性</strong>是由于不同关系数据库在不同的应用环境的特殊处理，往往需要用户自己设计一些特殊的约束条件</p></li></ul><h4 id="实体完整性">实体完整性</h4><ul class="lvl-0"><li class="lvl-2"><p>所有行都具有唯一的标识符，称为<strong>主键</strong></p></li><li class="lvl-2"><p>所有主关键字对应的<strong>主属性都不能为空，且取值唯一</strong></p></li></ul><h4 id="参照完整性">参照完整性</h4><p>若T1中存在P2作为外键，P2是T2的主键，则T1中每个元素在P2上取值<strong>必须满足下面其中一条</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>取空值</p></li><li class="lvl-2"><p>与T2上的主键中某个值对应</p></li></ul><p>如下图例：</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p6.png" alt="参照完整性图示" width="450" height="250"></p><h4 id="用户定义完整性">用户定义完整性</h4><p>在实际使用的时候，我们对数据库中的信息要进行一些限制，让获得的数据满足实际需要，这就是用户定义完整性，如：</p><ul class="lvl-0"><li class="lvl-2"><p>性别属性：男/女</p></li><li class="lvl-2"><p>专业属性：生物/电子/……</p></li><li class="lvl-2"><p>学生年龄属性：15~30</p></li></ul><h2 id="关系代数">关系代数</h2><h3 id="概述">概述</h3><p>关系代数是一个由各种运算组成的系统，通过关系运算得到的结果是一个集合，一个新的关系，可以被其他运算接着进行其他操作应用，即将<strong>一个操作的结果作为另一个操作的操作数</strong>，组成一个操作序列。这样的操作序列通常出现在查询语句中</p><p>三大要素：</p><ul class="lvl-0"><li class="lvl-2"><p>运算对象</p></li><li class="lvl-2"><p>运算符</p></li><li class="lvl-2"><p>运算结果</p></li></ul><p>四类运算符</p><ul class="lvl-0"><li class="lvl-2"><p>集合运算符</p></li><li class="lvl-2"><p>专门的关系运算符</p></li><li class="lvl-2"><p>比较运算符</p></li><li class="lvl-2"><p>逻辑运算符</p></li></ul><p>三类关系操作：</p><ul class="lvl-0"><li class="lvl-2"><p>传统的集合运算：交、并、差、笛卡尔积</p></li><li class="lvl-2"><p>专门的关系运算：投影、选择、连接、除</p></li><li class="lvl-2"><p>扩展的关系运算：广义投影、聚集函数和分组、递归闭包</p></li></ul><h3 id="传统集合运算符">传统集合运算符</h3><p><strong>交、并、差运算</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>并运算：</mtext><mi>R</mi><mo>∪</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo>∣</mo><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∨</mo><mi>t</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo><mspace linebreak="newline"></mspace><mtext>差运算：</mtext><mi>R</mi><mo>−</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo>∣</mo><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>t</mi><mo mathvariant="normal">∉</mo><mi>S</mi><mo stretchy="false">}</mo><mspace linebreak="newline"></mspace><mtext>交运算：</mtext><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo>∣</mo><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∨</mo><mi>t</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo><mspace linebreak="newline"></mspace><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mo>−</mo><mo stretchy="false">(</mo><mi>S</mi><mo>−</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">并运算：R \cup S = \{ t \mid t\in R \vee t\in S \}\\差运算：R-S=\{ t\mid t\in R \wedge t\notin S  \}\\交运算：R \cap S = \{ t\mid t\in R \vee t \in S \}\\R \cap S = R-(R-S)=S-(S-R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">并运算：</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">差运算：</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">交运算：</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></span></p><p>这些集合运算是对具有同样关系模式的各种关系进行运算，即几个关系之间的<strong>属性和域都相同，元组不同</strong>，才能进行集合运算，对关系的元组进行操作</p><h4 id="笛卡尔积">笛卡尔积</h4><p>两个分别为m目和n目的关系R和S的笛卡尔积是一个（m+n）列的元组的集合，新关系的前n列是关系R的一个元组，后m列是关系S的一个元组。<strong>若R有k1个元组，S有K2个元组，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R\times S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>有k1 * k2 个元组</strong></p><blockquote><p>目：也称为度，表示一个关系的属性的个数，也就是有多少列</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi><mover><mo><msub><mi>t</mi><mi>r</mi></msub><msub><mi>t</mi><mi>s</mi></msub></mo><mstyle mathsize="1.2em"><mo lspace="0em" rspace="0em">⌢</mo></mstyle></mover></mi><mo>∣</mo><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi><mo>∧</mo><msub><mi>t</mi><mi>s</mi></msub><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R\times S=\{ \overset{\large{\frown}}{t_rt_s} \mid t_r \in R \wedge t_s \in S \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5942em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3442em;"><span style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span><span class="mop"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-4.0151em;margin-left:0em;"><span class="pstrut" style="height:3.2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sizing reset-size3 size7"><span class="mrel">⌢</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></span></p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p9.png" alt="笛卡尔积原表" width="450" height="250"></p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p8.png" alt="笛卡尔积结果" width="450" height="250"></p><h3 id="专门关系运算符">专门关系运算符</h3><p><strong>选择</strong></p><p>选择运算，可以提取关系的水平方向的切片，即从关系中找出满足给定条件的所有元组，是从行的角度进行的运算</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>选择运算：</mtext><msub><mi>σ</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo>∣</mo><mi>R</mi><mo>∧</mo><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mo>=</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>T</mi><mi>r</mi><mi>u</mi><msup><mi>e</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">选择运算：\sigma_F(R)=\{ t\mid R\wedge F(t)==&#x27;True&#x27; \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">选择运算：</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><ul class="lvl-0"><li class="lvl-2"><p>F，即条件，由<strong>运算对象、算数比较符、逻辑运算符</strong>三个部分组成</p></li><li class="lvl-2"><p>t，满足给定条件所选择出来的元组，是操作对象的一个子集</p></li><li class="lvl-2"><p>R，操作对象，即被选择的关系</p></li></ul><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p10.png" alt="选择运算" width="450" height="250"></p><p><strong>投影</strong></p><p>关系R上的投影指的是从R中选择出若干属性列组成新的关系，记做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi_A(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>，投影操作是从列的角度进行的运算</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p11.png" alt="投影运算" width="400" height="250"></p><p><strong>连接</strong></p><p>连接也称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Θ</span></span></span></span>连接，连接运算是从两个任意关系R和S的笛卡尔积<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R\times S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中，选取（R关系）在A属性组上的值与（S关系）在B属性组上的值满足比较关系的元组</p><p>连接中比较常用也是最为重要的两种连接方式，为<strong>自然连接</strong>和<strong>条件连接</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>自然连接</strong>要求两个关系中进行比较的分量必须是相同的属性组，并且在运算结果中要去掉重复的属性，其具体的定义形式为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>⋈</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo>∣</mo><mi><mover><mo><msub><mi>t</mi><mi>r</mi></msub><msub><mi>t</mi><mi>s</mi></msub></mo><mstyle mathsize="1.2em"><mo lspace="0em" rspace="0em">⌢</mo></mstyle></mover></mi><mo>∣</mo><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi><mo>∧</mo><msub><mi>t</mi><mi>s</mi></msub><mo>∈</mo><mi>S</mi><mo>∧</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>t</mi><mi>s</mi></msub><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R\bowtie S=\{ t\mid \overset{\large{\frown}}{t_rt_s}\mid t_r\in R\wedge t_s\in S\wedge t_r[B]=t_s[b] \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5942em;vertical-align:-0.25em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3442em;"><span style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span><span class="mop"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-4.0151em;margin-left:0em;"><span class="pstrut" style="height:3.2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sizing reset-size3 size7"><span class="mrel">⌢</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">b</span><span class="mclose">]}</span></span></span></span></span></p><p>计算步骤：</p><ul class="lvl-2"><li class="lvl-4">计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⋈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \bowtie S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li><li class="lvl-4">选择同时出现在R和S中属性相等的元组</li><li class="lvl-4">去掉重复属性</li></ul><p>自然连接是<strong>同时从行和列的角度进行的操作</strong>，如果两个关系没有公共属性，则他们的自然连接就是笛卡尔积</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p12.png" alt="自然连接" width="450" height="250"></p></li><li class="lvl-2"><p><strong>条件连接</strong></p><p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Θ</span></span></span></span>为算术运算符，则关系R的第<code> i</code> 个属性和关系S的第<code> j</code> 个属性的连接定义为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi><munder><mo><mi>R</mi><mo>⋈</mo><mi>S</mi></mo><mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi>θ</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></munder></mi><mo>=</mo><msub><mi>σ</mi><mrow><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi>θ</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\underset{[i]\theta [j]}{R \bowtie S}=\sigma_{[i]\theta [j]}(R\times S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6543em;vertical-align:-0.971em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.304em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.971em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">]</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p13.png" alt="条件连接" width="450" height="250"></p></li></ul><p><strong>除</strong></p><ul class="lvl-0"><li class="lvl-2"><p><strong>分量</strong>：设关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A_1,A_2,...,A_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其一个关系为R，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[A_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>表示元组<code>t</code>中对应属性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的一个<strong>分量</strong></p></li><li class="lvl-2"><p><strong>象集</strong>：在关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(X,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span>中，<em><code>X</code></em>，*<code>Z</code><em>是属性组，<strong>x在R中的象集</strong>就是属性</em><code>X</code><em>的值为</em><code>x</code><em>的元组，在</em><code>Z</code>*上分量的集合</p></li><li class="lvl-2"><p><strong>除</strong>：给定关系<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(Y,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span>，其中*<code>X,Y,Z</code>*表示属性组<code>R</code>与<code>S</code>的 <code>Y</code>可以不同名，但必须出自相同的域集，<code>Z</code>可以为空</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>÷</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>∣</mo><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi><mo>∧</mo><msub><mi>π</mi><mi>Y</mi></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⊆</mo><msub><mi>Y</mi><mi>X</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R \div S=\{t_r[X]\mid t_r \in R\wedge \pi_Y(S)\subseteq Y_X \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>X</mi></msub></mrow><annotation encoding="application/x-tex">Y_X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<code>x</code>在<code>R</code>中的象集，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>t</mi><mi>r</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x=tr[X]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span></span></span></span></p><p>除运算的实例：</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p14.png" alt="除运算" width="450" height="250"></p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p15.png" alt="除运算解析" width="450" height="250"></p></li></ul><h3 id="扩展关系运算符">扩展关系运算符</h3><p><strong>聚集函数和分组</strong></p><ul class="lvl-0"><li class="lvl-2"><p>将关系中的某一<strong>属性值集合</strong>输入，将<strong>单一值</strong>作为结果返回</p></li><li class="lvl-2"><p>常用的聚集函数为：最大值（<strong>max</strong>）、最小值（<strong>min</strong>）、平均值（<strong>avg</strong>）、总和值（<strong>sum</strong>）、计数值（<strong>count</strong>）</p></li><li class="lvl-2"><p>输入聚集函数的集合中，一个值可以一出现多次，且与顺序无关，这样的集合称为<strong>多重集</strong></p></li><li class="lvl-2"><p>正常的集合中不能包含重复的值，是多重集的特例，若我们只想对重复的值计算一次，可以使用<strong>distinct</strong>去除重复值</p></li></ul><p>示例：</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-2/p16.png" alt="聚集函数和分组实例" width="450" height="250"></p><hr><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系模型的基本概念&quot;&gt;关系模型的基本概念&lt;/h2&gt;
&lt;h3 id=&quot;关系实例&quot;&gt;关系实例&lt;/h3&gt;
&lt;p&gt;是由命名的若干列和行组成的&lt;strong&gt;表格&lt;/strong&gt;，其中每一列称为&lt;strong&gt;属性&lt;/strong&gt;，每一行称为元组，关系实例中的数据称为&lt;</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记（1）--数据库基本概念</title>
    <link href="https://elementgc.github.io/2023/05/27/data-base-note-1/"/>
    <id>https://elementgc.github.io/2023/05/27/data-base-note-1/</id>
    <published>2023-05-27T05:47:17.000Z</published>
    <updated>2023-06-04T04:31:15.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库基本概念">数据库基本概念</h2><h3 id="基本术语">基本术语</h3><p><strong>数据（Data）</strong></p><p>保存在计算机中，能够背计算机识别、存储、处理的各种符号的统称</p><p><strong>信息（Information）</strong></p><p>经过加工处理过后的数据，是对数据的具体描述</p><blockquote><p><strong>数据是信息载体，信息是对数据的语义解释</strong></p></blockquote><p><strong>数据库（Database，DB）</strong></p><p>长期存储在计算机内的、<strong>有组织的</strong>、<strong>可共享的</strong>大量<strong>数据的集合</strong></p><h4 id="数据库管理系统（Database-Manage-System，DBMS）">数据库管理系统（Database Manage System，DBMS）</h4><p>位于<strong>用户与操作系统之间</strong>的一层<strong>数据管理软件</strong>，主要目标是让数据成为方便各种用户使用的资源，提高数据的<strong>安全性、完整性和可用性</strong></p><p><strong>元数据</strong></p><p>描述数据的数据，相当于是表格的<strong>表头</strong>，用来定义每一列的<strong>数据属性</strong>，如数据类型、格式、存储大小等</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p1.png" alt="元数据" width="450" height="250"></p><h3 id="系统术语">系统术语</h3><h4 id="数据库生态系统">数据库生态系统</h4><p>数据库中的所有数据都是在由数据库、操作系统、数据库管理系统、开发工具、应用程序、用户这几个部分组成的<strong>闭合的生态系统</strong>中流动，我们将这个系统称为数据库系统</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p2.png" alt="数据库生态系统" width="450" height="250"></p><p><strong>数据库系统（Database System）</strong></p><p>指一整个数据处理流程的系统，通常由<strong>硬件、软件、数据库和用户</strong>组成，其中负责对数据库进行设计、管理操作的用户称为<strong>数据库管理员（Database Administrator）</strong></p><p><strong>应用程序（Application）</strong></p><p>指能够执行<strong>某种功能</strong>的<strong>软件</strong>程序</p><h2 id="数据模型">数据模型</h2><p><strong>数据模型的概念</strong>：对现实世界数据特征的抽象和对现实世界的模拟——数字化</p><p><strong>组成要素</strong>：数据结构、数据操作和数据完整性</p><h3 id="概念数据模型">概念数据模型</h3><p>用户容易理解的、对现实世界特征数据的抽象，概念数据模型与所使用的具体的管理系统无关，是数据库设计人员与用户的交流语言**，常用的概念模型是<strong>实体—联系模型（Entity-Relationship，E-R模型）</strong></p><blockquote><p>E-R模型表示规则：实体集—矩形；属性—椭圆形；联系—菱形；连接—无向边</p></blockquote><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p3.png" alt="E-R模型表示" width="450" height="250"></p><p>E-R模型各个概念表示如下：</p><ul class="lvl-0"><li class="lvl-2"><p>实体（Entity）：客观存在并可以相互区别的事物，如：一名学生、一瓶水、一支笔</p></li><li class="lvl-2"><p>属性（Attribute）：瑟吉欧to所具有的某一特性，由<strong>型</strong>与<strong>值</strong>共同表示，如：某学生的学号为0012，则属性的型为<strong>学号</strong>，值为<strong>0012</strong>。<strong>一个实体可以通过若干个属性进行刻画</strong></p></li><li class="lvl-2"><p>实体型（Entity Type）：通过使用**实体名(属性名集合)**这种方式来表示一个类型的实体，如：学生(学号，姓名，年龄，性别，系)</p></li><li class="lvl-2"><p>实体集（Entity Set）：所有使用同一个实体型的集合，如：所有的学生</p></li><li class="lvl-2"><p><strong>码（Key）</strong>：也称为<strong>键</strong>，实体型中，能够<strong>唯一</strong>标识一个实体的属性或属性集，即只要我们通过这个属性或属性集的具体值，我们就能够确定这一个实体，如：学生的学号</p></li><li class="lvl-2"><p>域（Domain）：某一属性的取值范围，如：姓名的域为字符串集合，学生的年龄属性的域为小于40的整数等等</p></li><li class="lvl-2"><p>联系（Relationship）：分为单个实体型的内部联系和实体型之间的联系，都具有一对一、一对多和多对多这几种联系类型</p></li></ul><h3 id="逻辑数据模型">逻辑数据模型</h3><p>是用户从数据库中能够看到的数据模型，是具体DBMS所支持的数据模型</p><p>主要的逻辑数据模型有：</p><ul class="lvl-0"><li class="lvl-2"><p>层次模型</p></li><li class="lvl-2"><p>网状模型</p></li><li class="lvl-2"><p><strong>关系模型</strong></p></li><li class="lvl-2"><p><strong>面向对象模型</strong></p></li></ul><h4 id="层次模型">层次模型</h4><p>用<strong>树形</strong>数据结构来表示各类实体以及实体间关系，具有如下几个特点</p><table bgcolor="white" width="70%">    <tr>    <th width="200px">特点</th>    <th>优点</th>    <th>缺点</th>     </tr>    <tr align="center"><td>每棵树有且仅有根节点没有双亲</td>    <td>结构模型简单，层次分明</td>    <td>不能直接表示多实体型之间的多对多关系</td> </tr>    <tr align="center"><td>根节点外其他节点有且仅有一个双亲节点</td>        <!--所以为啥要叫双亲-->    <td>节点联系简单，建立的数据库查询速率很高</td>    <td>对于数据的插入和删除限制多，麻烦</td> </tr>    <tr align="center"><td>父节点对子节点是一对多的关系</td>    <td>具有良好的数据完整性</td>    <td>查询子节点必须通过双亲结点</td> </tr></table><h4 id="网状模型">网状模型</h4><p>解决了层次模型难以表示非层次关系的问题，更加具有普遍性</p><table bgcolor="white" width="70%">    <tr>    <th width="200px">特点</th>    <th>优点</th>    <th>缺点</th>     </tr>    <tr align="center"><td>有一个以上的节点没有双亲</td>    <td>能更为客观地描述时间，实现多种复杂关系</td>    <td>数据结构复杂，且应用环境越大越复杂，不便于用户使用</td> </tr>    <tr align="center"><td>允许节点拥有多个双亲</td>        <!--所以为啥要叫双亲-->    <td>具有良好的性能和存储效率</td>        <td>数据定义语言<b>(DDL)</b>和数据操作语言<b>(DML)</b>相当复杂，难用</td> </tr>    <tr align="center"><td>允许两个节点之间有多种联系</td>    <td></td>    <td>系统复杂、结构复杂，缺乏独立性加重了编写程序的负担</td> </tr></table><h4 id="关系模型（等后面细说）">关系模型（等后面细说）</h4><p>结合了层次模型和网状模型的优点，摒弃了部分缺点，并且有强烈的数学支撑，非常优秀（主要考察内容）</p><h2 id="数据库管理系统">数据库管理系统</h2><h3 id="主要功能">主要功能</h3><h4 id="定义功能">定义功能</h4><p>提供数据定义语言<strong>DDL（Data Definition Language）</strong>，对各级数据模式进行精确定义。即完成对数据库、表的定义与创建工作（create）</p><h4 id="操作功能">操作功能</h4><p>提供数据操作语言<strong>DML（Data Manipulation Language）</strong>，对数据库中的数据进行<strong>追加、插入、修改、删除、检索</strong>等操作（最为常用）</p><h4 id="控制功能">控制功能</h4><p>提供数据控制语言<strong>DCL（Data Control Language）</strong>，对数据库中的数据进行并发控制、安全性控制和完整性控制，保证数据正确有效和数据库正常运行</p><h4 id="组织、存储和管理功能">组织、存储和管理功能</h4><p>对数据库中需要存放的各种数据（如：数据字典，用户数据，存储路径等）的组织、存储和管理工作，以确定这些数据的文件结构和存取方式，提高存储空间利用率以及对数据库进行操作的效率</p><h4 id="数据的建立维护功能">数据的建立维护功能</h4><p>包括但不限于：数据库初始数据的输入、转换功能、数据库的转储、恢复功能、重组织功能和性能监视、分析功能等</p><p>以下为展示数据库功能结构，以便于更好地理解</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p4.png" alt="数据库管理系统结构" width="450" height="250"></p><h3 id="基本特点">基本特点</h3><h4 id="数据结构化">数据结构化</h4><p>让整体数据结构化，这是数据库的主要特征之一，也是区别于文件系统的本质所在</p><h4 id="数据共享性高、冗余度低、易扩充">数据共享性高、冗余度低、易扩充</h4><p>从面向<strong>整个系统的角度</strong>来看待和描述数据，减小了数据的冗余，节约存储空间，缩短存取时间，避免了数据的单一性和割裂性，避免数据至今的不相容和不一致</p><h4 id="数据独立性高">数据独立性高</h4><p>数据是脱离应用而存在的，是单独出来的，具有逻辑独立性和物理独立性</p><h4 id="由DBMS统一管理和控制">由DBMS统一管理和控制</h4><p>统一的数据管理可以保障数据的安全性、数据完整性和并发控制</p><h2 id="数据库系统的组成">数据库系统的组成</h2><h3 id="物理组成——生态组成">物理组成——生态组成</h3><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p2.png" alt="数据库生态系统" width="450" height="250"></p><p>所有对于数据的操作都在这个闭合的生态系统中完成，有始有终，没有外泄</p><h3 id="模式结构——三级模式">模式结构——三级模式</h3><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p5.png" alt="数据库的三级模式结构" width="450" height="250"></p><p>数据库系统的三级模式结构是指数据库系统是由<strong>外模式、模式、内模式</strong>三级构成，三个模式从物理意义上来说都是<strong>同一个事物</strong>，只是<strong>从不同的层次进行观察时的解释不同</strong></p><h4 id="外模式（External-Schema）：">外模式（External Schema）：</h4><p>也称子模式（Subschema）或用户模式（User Schema），是数据库用户（包括应用程序员和最终用户）能够看见和使用的<strong>局部数据</strong>的逻辑结构和特征的描述，是数据库用户的<strong>数据视图</strong>，是与<strong>某一应用</strong>有关的<strong>数据的逻辑表示</strong></p><ul class="lvl-0"><li class="lvl-2"><p>一个数据库可以有多个外模式</p></li><li class="lvl-2"><p>外模式是数据安全性的保证</p></li><li class="lvl-2"><p>外模式就是用户视图，不能进行操作</p></li></ul><h4 id="模式：">模式：</h4><p>又称概念模式或逻辑模式，是数据库中<strong>全体数据</strong>的逻辑结构和特征的描述，是所有用户的公共数据视图。上不管具体应用程序和开发工具，下不管数据的物理存储细节和硬件环境，仅仅是将他们这些关系进行一个存储</p><ul class="lvl-0"><li class="lvl-2"><p>一个数据库只能有一个模式</p></li><li class="lvl-2"><p>定义模式时不仅要定义数据的逻辑结构，而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系</p></li><li class="lvl-2"><p>数据库模式以某一种数据模型为基础，是数据库数据在逻辑级上的视图</p></li></ul><h4 id="内模式（Internal-Schema）：">内模式（Internal Schema）：</h4><p>也称存储模式（Storage Schema），它是数据保存了物理结构和存储方式，是数据在数据库内部的表示方式</p><ul class="lvl-0"><li class="lvl-2"><p>一个数据库只能有一个内模式</p></li><li class="lvl-2"><p>内模式最靠近物理存储，与实际的存储方式有关</p></li></ul><h3 id="模式结构——二级映射">模式结构——二级映射</h3><p>为了能够在内部实现三级模式这样一个抽象层次的联系与转换，DBMS在三级模式之间提供了二级映射，以此来保证三个模式之间的数据独立性，即逻辑独立性和物理独立性</p><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p6.png" alt="二级映射总体结构" width="450" height="250"></p><h4 id="外模式-模式映射">外模式/模式映射</h4><p><img src="https://elementgc.github.io/2023/05/27/data-base-note-1/p7.png" alt="外模式/模式映射" width="450" height="250"></p><p>如上图所示，用户需要获得的是最上面的这张表，而我们数据库中并不直接存在，此时就是通过外模式/模式的映射来对多个表中的数据进行整合，实现必要的数据信息对用户的展示，保证了数据的逻辑独立性</p><h4 id="模式-内模式映射">模式/内模式映射</h4><p>数据库中的模式与内模式都只有一个，所以模式/内模式的映射是唯一的，它确定了数据的全局逻辑结构与存储结构之间的对应关系，保证在存储结构发生变化时，使得数据的全局逻辑结构的改变不会受到影响，从而不必因此重新修改应用程序，保证了数据的物理独立性</p><h3 id="模式结构——优点">模式结构——优点</h3><ul class="lvl-0"><li class="lvl-2"><p>保证数据的独立性</p></li><li class="lvl-2"><p>简化的用户接口</p></li><li class="lvl-2"><p>有利于数据共享与安全保密</p></li></ul><hr><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库基本概念&quot;&gt;数据库基本概念&lt;/h2&gt;
&lt;h3 id=&quot;基本术语&quot;&gt;基本术语&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数据（Data）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保存在计算机中，能够背计算机识别、存储、处理的各种符号的统称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息（I</summary>
      
    
    
    
    
    <category term="数据库原理及应用" scheme="https://elementgc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="学习笔记" scheme="https://elementgc.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何将本地资源上传到github的远程仓库</title>
    <link href="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/"/>
    <id>https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/</id>
    <published>2023-05-25T00:26:58.000Z</published>
    <updated>2023-06-03T01:35:20.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常规情况下的操作">常规情况下的操作</h2><h3 id="1-检查当前分支">1. 检查当前分支</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p1.png" alt="查看当前分支"></p><h3 id="2-将文件添加到缓存区并提交信息">2. 将文件添加到缓存区并提交信息</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;&lt;提交信息&gt;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2.png" alt="git add .结果"><br><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p3.png" alt="git commit 结果"></p><h3 id="3-将更改上传（push）到远程仓库">3.将更改上传（push）到远程仓库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push &lt;为远程仓库在本地起的别名&gt; &lt;远程仓库的分支名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p4.png" alt="git push 命令运行结果"><br><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p5.png" alt="上传结果展示"></p><h2 id="一些小操作">一些小操作</h2><h3 id="查看git-add-都添加了些什么：">查看<code>git add .</code>都添加了些什么：</h3><p>使用<code>git status</code>来进行查看</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2-1.png" alt="git status 结果"></p><h3 id="查看链接了那些远程仓库">查看链接了那些远程仓库</h3><p>使用<code>git remote</code>进行查看链接的所有远程仓库的别名</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2-2.png" alt="链接的远程仓库别名"><br>使用<code>git remote -v</code>查看远程仓库的地址</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><img src="https://elementgc.github.io/2023/05/25/upload-to-remote-repositories/p2-3.png" alt="查看远程仓库的地址"></p><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常规情况下的操作&quot;&gt;常规情况下的操作&lt;/h2&gt;
&lt;h3 id=&quot;1-检查当前分支&quot;&gt;1. 检查当前分支&lt;/h3&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="git" scheme="https://elementgc.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>配置个人博客的一些相关事项</title>
    <link href="https://elementgc.github.io/2023/05/24/Blog-configuration/"/>
    <id>https://elementgc.github.io/2023/05/24/Blog-configuration/</id>
    <published>2023-05-24T10:33:21.602Z</published>
    <updated>2023-06-04T04:31:24.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELement——GC的个人博客仓库">ELement——GC的个人博客仓库</h2><h3 id="分支-main">分支-main</h3><p>目前只有一个README，用来帮自己弄懂这个是拿来干嘛的</p><h3 id="hexo">hexo</h3><p>在我们的博客设置文件中，我们设置了</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:ElementGC/ElementGC.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">hexo</span></span><br></pre></td></tr></table></figure><p>这一设置让我们能够将本地静态网站布置好<code> hexo g</code>之后将网站结果保存到对应github仓库的分支<code>hexo</code>中，也就是说，其实github加载的网站就是从hexo分支中弄出来的</p><h3 id="sourcelib">sourcelib</h3><p>这是我为了保险起见加的，毕竟说不定什么时候一不小心本地仓库没了都有可能，所以我把原本的<strong>配置文件</strong>~~<em>这个是重点</em>~~也打包好放上来，实现理论上来说只要安装好<code>git</code>和<code>hexo</code>就可以直接从网上拉取这个包然后一个    <code>hexo g  &amp;&amp; hexo s</code>直接也实现本地配置网页，然后好接着改，所以这玩意得及时更新</p><h2 id="hexo配置-butterfly主题">hexo配置-butterfly主题</h2><p>本博客主要就是基于hexo框架下的butterfly主题建立的博客，因此也会在此详细解释一些比较常用，更加个性化的配置设置</p><h3 id="基本设置">基本设置</h3><h4 id="根目录下的-config-yml文件-hexo官方文档-配置">根目录下的<code>_config.yml</code>文件 <a href="https://hexo.io/zh-cn/docs/configuration">hexo官方文档-配置</a></h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#x27;心有所向，日复一日，必有精进&#x27;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;欢迎来到ELement_GC的咸鱼博客&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;欢迎光临，希望你能在这里找到您想要的&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Element_GC</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>title 为网站总标题，就是一点开主页的网址名称，以及该主题下的主页正中间以及导航栏左上角的文字描述</p></li><li class="lvl-2"><p>subtitle 为网站副标题，在 <code>butterfly</code> 主题下一般情况下不会显示，这个主题的配置里面更改设置才会出来</p></li><li class="lvl-2"><p>discription 为网站描述，在 <code>butterfly</code>主题下表现为侧边栏中，作者名字下的签名</p></li><li class="lvl-2"><p>keyword 关键字，没用过</p></li><li class="lvl-2"><p>author 作者，这个肯定得写自己的名字</p></li><li class="lvl-2"><p>language 语言，肯定得写中文啊，不过好像 一开始 <code>hexo init</code>直接生成的配置文件里面是英文，可以改成 <code>zh-CN</code></p></li><li class="lvl-2"><p>timezone 时区，一般以电脑上的时区为准，中国的话直接设成 <code>Asia/Shanghai</code>就行</p></li></ul><p>主页各个部分结构如下图所示<br><img src="https://elementgc.github.io/2023/05/24/Blog-configuration/p1.png" alt="主标题、副标题与导航栏"><br><img src="https://elementgc.github.io/2023/05/24/Blog-configuration/p2.png" alt="头像、作者、与描述"><br><br></p><p>更多的设置可以去<a href="https://hexo.io/zh-cn/docs/configuration">hexo官方文档-配置</a>查看</p><h3 id="插件更新设置">插件更新设置</h3><p>出这么一个的最初原因还是我想调整博客里面图片的大小，然后顺藤摸瓜找到了这篇文档<a href="https://blog.csdn.net/qq_42951560/article/details/123596899">【Hexo】选择更高级的Markdown渲染器</a>，在这里做一个大致的介绍：</p><ol><li class="lvl-3"><p>渲染器的选择：</p></li></ol><p>Hexo 默认搭配的 Markdown 渲染器是 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>，但其支持的渲染格式有限，对于要求多元的博客来说有时候并不是很合适，因此可以改用功能更多的 <a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a> 渲染器，以下是 hexo-renderer-markdown-it 的安装步骤：</p><h4 id="卸载与安装">卸载与安装</h4><p>卸载<code>hexo-renderer-marked</code>渲染器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><p>安装<code>hexo-renderer-markdown-it</code>渲染器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i markdown-it-checkbox</span><br><span class="line">npm i markdown-it-imsize</span><br><span class="line">npm i markdown-it-expandable</span><br></pre></td></tr></table></figure><p><em>只安装这三个主要是因为其他的插件在安装渲染器的时候就一起安装好了</em></p><h4 id="配置">配置</h4><p>将如下文本复制到<code>hexo</code>根目录的配置文本最底下就行</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&quot;language-&quot;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&quot;“”‘’&quot;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-cjk-breaks</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-deflist</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-emoji</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-mark</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-checkbox</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-imsize</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-expandable</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">success</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">tips</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">warning</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">markdown-it-container</span></span><br><span class="line">      <span class="attr">options:</span> <span class="string">danger</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&quot;header-anchor&quot;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&quot;left&quot;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&quot;¶&quot;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure><h4 id="插件的用法">插件的用法</h4><p>这里只讲一个已经用上的 <code>markdown-it-imsize</code> 插件</p><p>通常来说，md文本导入图片使用的是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片描述](image.png)</span><br></pre></td></tr></table></figure><p>格式的命令，而这个插件可以通过在地址后面添加尺寸的方式实现图片尺寸的更改，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片描述](image.png =300x200)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，等号<code>=</code>前面必须与地址空开一格，后面必须紧跟着尺寸，而且中间的那个就是字母xyz的<strong>x</strong>，<strong>不是乘号</strong>，</p><p>当然，还有许多有趣的渲染命令，这里就不一一例举了，可以在文档<a href="https://blog.csdn.net/qq_42951560/article/details/123596899">【Hexo】选择更高级的Markdown渲染器</a>中进行查看</p><h3 id="butterfly主题设置">butterfly主题设置</h3><p><code>butterfly</code> 的主题设置可以说非常的丰富多彩，这里只举例几个比较常用的以及我已经用上了的配置（可能有些配置设置我已经改了但我没注意到，那也可以在官网上查看），这里也附上butterfly主页的官方网站——<a href="https://butterfly.js.org/">butterfly官网</a></p><h4 id="基本设置-查看文档">基本设置  <a href="https://butterfly.js.org/posts/4aa8abbe">查看文档</a></h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">   <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">   <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="comment">## 列表||fas fa-list ||hide:</span></span><br><span class="line">     <span class="comment">#Music: /music/ || fas fa-music</span></span><br><span class="line">     <span class="comment">#Movie: /movies/ || fas fa-video</span></span><br><span class="line">   <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">   <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>这是导航栏部分的设置，没错，开头那里是可以设置成中文的，每一项都可以一一对应上，不想要可以的直接注释掉。除了主页以外其他页面都有个对应的文件夹的，| | 后面的是图标名，我也不知道还有哪些，有空可以去找找看。至于对应的文件夹在哪……我还真没找到</p><blockquote><p>据官方文档的<a href="https://butterfly.js.org/posts/dc584b87">主题页面</a>说，在文档的根目录执行 <code>hexo new page tags</code>就可以创建新标签页，也就是导航栏对应页面，然后生成的文件位置就在<code>source/tags/index.md</code>。很明显我没弄……</p></blockquote><p>列表后面的| | hide是用于隐藏子目录的，用了之后可以移到对应位置展开子目录（音乐和电影）</p><h4 id="给你的博客加个封面查看文档">给你的博客加个封面<a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2">查看文档</a></h4><p>封面的添加有两种方法</p><ul class="lvl-0"><li class="lvl-4"><p>从配置文件来随机添加分配封面</p></li><li class="lvl-4"><p>在博客文档的头部添加封面指引</p></li></ul><p>优先级分别为：</p><blockquote><p>博客文档的头部 &gt; 配置文件分配 &gt; 不设置封面</p></blockquote><ol><li class="lvl-3"><p>配置文件</p></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment">## 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">## 封面显示的位置</span></span><br><span class="line">  <span class="comment">## 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">## 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">img/---</span> <span class="comment">#img为butterfly主题路径下的\source\img，后面直接跟该文件夹里面的对应文件即可</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">img/---</span> <span class="comment">#若存在多个这种索引，到时候给文章添加封面就会实行随机添加的方法，当然，第一次执行添加完之后就不会再改了</span></span><br></pre></td></tr></table></figure><blockquote><p>根据最新情况来看，好像如果对文章进行更新的话，使用默认随机标题的文章的封面也会更新成一个随机的</p></blockquote><ol start="2"><li class="lvl-3"><p>md文档头部添加</p></li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:    #必，没写的话会给你分配一个“无题”上去</span><br><span class="line">date:     #必，没写的话会按照默认的时间给你填上去</span><br><span class="line">updated:  #可，没写的话会按照默认的时间给你填上去</span><br><span class="line">tags:     #从这个开始下面的基本都是可要可不要的</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:    #这个就是封面，在这里填上封面的地址就行，格式和配置文档的一样，也是通过那种方式去找（和博客内引用图片的方式一点也不一样）</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line"><span class="section">abcjs:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="设置一下代码块">设置一下代码块</h4><h5 id="代码块自动换行">代码块自动换行</h5><p>因为有时候代码会超长，在页面宽度不够的情况下一行显示不完，如果不设置的话他底下会出现一个滑动条让你左右滑动，就很麻烦；</p><p>这一步需要设置两个文档，一个是butterfly的配置文件，一个是hexo根目录下的配置文件，一个一个来：</p><p>butterfly内的配置文件,只有这一行需要设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>hexo的配置文件，看你的渲染方法，一般两个都找一找</p><ul class="lvl-0"><li class="lvl-2"><p>highlight 渲染</p></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#&lt;-这里是true就说明用的是这个渲染方法</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment">## &lt;- 改这里</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>prismjs 渲染</p></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>   <span class="comment">#&lt;-这里是true就说明用的是这个渲染方法</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span> <span class="comment">## &lt;- 改这里</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="代码块限制高度">代码块限制高度</h5><p>有些博客可能里面有一大堆代码块，但有时候我们根本就不想看这些代码，代码块过长反而会让我们翻得难受，一不小心就翻过了，所以限制代码块的高度是必要的</p><p>我们需要在butterfly的配置文件中找到这一行</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment">## unit: px</span></span><br></pre></td></tr></table></figure><p>然后将<code>false</code>修改成我们想要的最大高度（我自己设置的是300），默认单位是px，要是不知道有多长的话可以用截图工具估一下（一般你电脑截图的时候人都会给你显示截图的长和宽的，那个的单位就是px）</p><hr><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ELement——GC的个人博客仓库&quot;&gt;ELement——GC的个人博客仓库&lt;/h2&gt;
&lt;h3 id=&quot;分支-main&quot;&gt;分支-main&lt;/h3&gt;
&lt;p&gt;目前只有一个README，用来帮自己弄懂这个是拿来干嘛的&lt;/p&gt;
&lt;h3 id=&quot;hexo&quot;&gt;hexo&lt;/h3</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客" scheme="https://elementgc.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>RFID防冲突算法实验报告</title>
    <link href="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/"/>
    <id>https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/</id>
    <published>2023-05-24T03:47:14.099Z</published>
    <updated>2023-06-02T06:23:46.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实验目的和要求">1. 实验目的和要求</h2><p>（1） 掌握RFID工作原理</p><p>（2）掌握RFID标签冲突产生原理</p><p>（3）掌握常见的RFID防冲突识别算法</p><p>（4）对常见的RFID防冲突识别算法进行实验比较</p><h2 id="2-实验环境">2. 实验环境</h2><p>使用Python语言进行代码的编译与运行，<code>python</code>版本为<code>3.9.13</code>使用的集成开发环境IDE为<code>Pycharm</code>，版本为<code>17.0.5</code>完成实验所需要的数据包为：<code>random</code>数据包，用于生成随机数，分配时隙与标签</p><h2 id="3-实验原理">3. 实验原理</h2><h3 id="3-1-帧时隙ALOHA-FSA-RFID防冲突识别算法：">3.1 帧时隙<code>ALOHA(FSA)</code> RFID防冲突识别算法：</h3><p>将<code>ALOHA</code>算法分为许多时隙，其中若干时隙为一帧，阅读器以帧为单位进行识别。在<code>FSA</code>算法中，每一帧开始时阅读器就广播帧的长度f，指明下一帧所包含的时隙个数，并激活识别区域中的所有标签。每个标签在接收到帧长f之后随机独立地在0~(f-1)中选择一个整数作为自己发送标识符的时隙序号，并将这个序号存在寄存器SN中。在下一帧的每一个时隙中，阅读器通过时隙开始命令启动一个新的时隙，如果标签SN的值为零立即发送标识符号，如果不等于零，则将SN值减一并且不发送标识符。对于标签而言，如果标识符发送成功（即无冲突），则该标签立即进入休眠状态，在之后的时隙中不再活动。如果有冲突发生，则该标签进入等待状态，在下一帧中重新选择一个时隙发送标识符。阅读器不断重复以上过程，直到在某一帧中没有收到任何标签信号，则认为所有标签均被识别。基于上述原理，我们可以得知在FSA算法中存在三种状态的时隙：</p><p>（1）空时隙，即没有标签相应；</p><p>（2）单时隙，即只有一个标签相应；</p><p>（3）冲突时隙，即不只一个标签相应，发生冲突。当且仅当在单时隙中时，阅读器才能成功识别一个标签。我们可以设计出FSA算法流程如下所示：</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p1.png" alt="图1. FSA算法流程图"></p><h3 id="3-2-基于查询二进制树的防冲突算法">3.2 基于查询二进制树的防冲突算法</h3><p>每个标签需要维持一个计数器，计数器初始值为0。在每个时隙开始时，如果标签的计数器为0则立即发送自己的标识符号，否则该时隙不响应。标签识别成功，进入沉默状态，每个时隙结束时阅读器会将接收到的时隙状态反馈给标签，场内的标签根据结束时阅读器反的结果对自己维持的计数器进行调整。因此，对于是否冲突两种情况，也需要做出对应的判断：</p><ol><li class="lvl-3"><p>冲突时隙：参与响应的标签从0/1中随机选择一个，将其加到自己的计数器上；没有参与的标签计数器加1。由此可以将冲突的标签分为两个集合。</p></li><li class="lvl-3"><p>没有冲突：单时隙，成功识别，进入沉默状态，没有被识别的标签自己减1<br>上述算法原理可以简化成下图所示流程<br><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p2.png" alt="图2. 查询二进制树算法流程"></p></li></ol><h2 id="4-实验步骤（包含结果分析和源代码）">4. 实验步骤（包含结果分析和源代码）</h2><h3 id="4-1-帧时隙ALOHA（FSA）RFID防冲突识别算法">4.1 帧时隙ALOHA（FSA）RFID防冲突识别算法:</h3><h4 id="源代码：">源代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 帧参数设置</span></span><br><span class="line">tatal = <span class="number">100</span>  <span class="comment"># 发送时间范围</span></span><br><span class="line">length = <span class="number">1</span>  <span class="comment"># 帧长</span></span><br><span class="line">solt = <span class="number">1</span>  <span class="comment"># 时隙</span></span><br><span class="line">num = <span class="number">100</span>  <span class="comment"># 总帧数</span></span><br><span class="line"><span class="built_in">list</span> = []  <span class="comment"># 用来存放每一个数据帧</span></span><br><span class="line"><span class="comment"># 定义帧类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Frame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, time</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 帧的名字</span></span><br><span class="line">        self.send_time = time  <span class="comment"># 帧的发送时间</span></span><br><span class="line"><span class="comment"># 随机产生每个帧的发送时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="comment"># 帧的名字用序号代替，发送时间都是整数</span></span><br><span class="line">    name = i</span><br><span class="line">    send_time = random.randrange(<span class="number">0</span>, tatal + <span class="number">1</span>, solt)</span><br><span class="line">    frame = Frame(name, send_time)</span><br><span class="line">    <span class="built_in">list</span>.append(frame)</span><br><span class="line"><span class="comment"># 按发送时间属性排序(按时间发送)</span></span><br><span class="line"><span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x.send_time)  <span class="comment"># lambda定义了一个隐含函数x,该函数返回send_time属性</span></span><br><span class="line">success = <span class="number">0</span>  <span class="comment"># 成功发送帧的数量</span></span><br><span class="line">send_frame = [] <span class="comment">#成功发送帧的集合</span></span><br><span class="line">conflict = <span class="number">0</span>  <span class="comment"># 发生冲突即本轮传输失败的帧数量</span></span><br><span class="line"><span class="comment"># 有帧发送、并且发送时间在通信时间内才发送</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">list</span>) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">list</span>[<span class="number">0</span>].send_time &lt;= tatal:</span><br><span class="line">    current_frame = <span class="built_in">list</span>[<span class="number">0</span>]  <span class="comment"># 当前帧一直都是list[0]</span></span><br><span class="line">    <span class="comment"># 冲突检测</span></span><br><span class="line">    address = []  <span class="comment"># 存放冲突帧的name</span></span><br><span class="line">    <span class="comment"># 所有冲突帧存储到address,没有则len(address)=1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">list</span>[i].send_time == current_frame.send_time:</span><br><span class="line">            address.append(i)</span><br><span class="line">    <span class="comment"># 没有冲突,移除列表，同时成功发送帧数量加1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(address) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">list</span>.remove(current_frame)</span><br><span class="line">        send_frame.append(current_frame)</span><br><span class="line">        success += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 发生冲突</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> address:</span><br><span class="line">            <span class="built_in">list</span>[i].send_time += random.randint(<span class="number">1</span>, tatal + <span class="number">1</span>) * solt  <span class="comment"># 延迟发送时间k个时隙</span></span><br><span class="line">        conflict += <span class="number">1</span>  <span class="comment"># 冲突帧的数量加1</span></span><br><span class="line">        <span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x.send_time)  <span class="comment"># 重新排序</span></span><br><span class="line">        address.clear()</span><br><span class="line"><span class="comment"># 计算吞吐率</span></span><br><span class="line">z = success / num</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通信时间:&quot;</span>, tatal, <span class="string">&quot;帧长:&quot;</span>, length)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成功发送的帧数量:<span class="subst">&#123;success&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;发送的帧总数量:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;冲突次数:<span class="subst">&#123;conflict&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;吞吐率:<span class="subst">&#123;z*<span class="number">100</span>&#125;</span>%&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;发送成功的帧分别为&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(send_frame)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;编号：<span class="subst">&#123;send_frame[i].name&#125;</span>；时间：<span class="subst">&#123;send_frame[i].send_time&#125;</span>&quot;</span>,end=<span class="string">&quot;\t\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">6</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果及分析：">运行结果及分析：</h4><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p1.png" alt="图3. "></p><p>在代码运行的过程中，我们对发生冲突的次数进行了统计，观察并记录在规定的时间内（即一定的循环次数内）能够成功发送的帧及其数量，并作为结果进行输出。可以看出，在一定的通信时长内，同样数量的帧总是会发生冲突，导致无法及时完全发送出去，吞吐率往往不及一半。</p><h3 id="4-2-基于查询二进制树的防冲突算法">4.2 基于查询二进制树的防冲突算法</h3><h4 id="源代码">源代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 帧参数设置</span></span><br><span class="line">num = <span class="number">10</span>  <span class="comment"># 总标签数</span></span><br><span class="line"><span class="built_in">list</span> = []  <span class="comment"># 用来存放每一个标签</span></span><br><span class="line">conflict = <span class="number">0</span>  <span class="comment"># 发生冲突即本轮传输失败的帧数量</span></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"><span class="comment"># 定义帧类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 标签名</span></span><br><span class="line">        self.timer = [<span class="number">0</span>]  <span class="comment"># 计数器</span></span><br><span class="line">        self.active = <span class="number">1</span> <span class="comment"># 活跃状态</span></span><br><span class="line"><span class="comment">#检查计数器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Check_Timer</span>(<span class="params">timerA,timerB</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(timerA)):</span><br><span class="line">        <span class="keyword">if</span> timerA[i] != timerB[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#查询二进制树主程序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Check_Lable</span>(<span class="params">boarder,<span class="built_in">list</span></span>):</span><br><span class="line">    same = []</span><br><span class="line">    <span class="keyword">global</span> times</span><br><span class="line">    times += <span class="number">1</span></span><br><span class="line">    insame = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="comment"># if list[i].active : #仅对活跃的标签进行检测</span></span><br><span class="line">        issame = Check_Timer(boarder,<span class="built_in">list</span>[i].timer)</span><br><span class="line">        <span class="keyword">if</span> issame:<span class="comment">#前缀相同,则重新加前缀，记录在案</span></span><br><span class="line">            <span class="built_in">list</span>[i].timer.insert(<span class="number">0</span>,random.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            same.append(<span class="built_in">list</span>[i])</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#前缀不同，另做一个集合</span></span><br><span class="line">            insame.append(<span class="built_in">list</span>[i])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(same) == <span class="number">1</span>:  <span class="comment">#只有一个重复的，就说明这个标签确定对上了</span></span><br><span class="line">        same[<span class="number">0</span>].active = <span class="number">0</span></span><br><span class="line">        same[<span class="number">0</span>].timer.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(same) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment">#前缀加0.继续进行</span></span><br><span class="line">        boarder.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        Check_Lable(boarder,same)<span class="comment"># 冲突的标签拉进去</span></span><br><span class="line">        boarder.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(insame) != <span class="number">0</span>:</span><br><span class="line">        boarder[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        Check_Lable(boarder, insame)</span><br><span class="line"><span class="comment"># 生成每一帧及其计数器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="comment"># 标签的名字用序号代替，发送时间都是整数</span></span><br><span class="line">    name = i</span><br><span class="line">    frame = Lable(name)</span><br><span class="line">    <span class="built_in">list</span>.append(frame)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">fin_res = Check_Lable([<span class="number">0</span>],<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># times = fin_res</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;本次执行共有<span class="subst">&#123;num&#125;</span>个标签&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总共执行次数为<span class="subst">&#123;times&#125;</span>次&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;各个标签的位置分别为:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;序号：<span class="subst">&#123;<span class="built_in">list</span>[i].name&#125;</span>——二进制树坐标：<span class="subst">&#123;<span class="built_in">list</span>[i].timer&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果及分析">运行结果及分析</h4><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p4.png" alt="图4. "></p><p>在该代码中，我们通过类似于构造二叉树的方法建立二进制树，每一帧都进行一次广播并查找有无坐标（即计数器）重复项，若有，则对重复项随机添加前缀并再次广播，直到将全部重复项都区分开来，才算完成，并退回到上一层，就这样逐步分化，最终形成二进制树。</p><h3 id="4-3-分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别">4.3 分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别</h3><p>(1) 10个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p5.png" alt="图5. " width="300" height="300"></p><p>(2)50个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p6.png" alt="图6. " width="300" height="300"></p><p>(3)100个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-algorithm/p7.png" alt="图7. " width="300" height="300"></p><h3 id="4-4-数据表格绘制">4.4 数据表格绘制</h3><table border="2px solid #000" cellspacing="0" cellpadding="0" bordercolor="black" bgcolor="white">    <tr>        <th>标签数量</th>        <th>ALOHA算法</th>        <th>查询二进制树</th>        <th>运行结果</th>    </tr>    <tr align="center">        <td rowspan="3">10</td>        <td>3</td>        <td>10</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>13</td>        <td>20</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>1.3</td>        <td>2</td>        <td>平均识别时长</td>    </tr>    <tr align="center">        <td rowspan="3">50</td>        <td>52</td>        <td>63</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>102</td>        <td>121</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>2.04</td>        <td>2.42</td>        <td>平均识别时长</td>    </tr>    <tr align="center">        <td rowspan="3">100</td>        <td>76</td>        <td>149</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>176</td>        <td>272</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>1.76</td>        <td>2.72</td>        <td>平均识别时长</td>    </tr></table><h3 id="4-5-算法分析">4.5 算法分析</h3><p>如表格所示。我们分别统计并计算了ALOHA算法与查询二进制树算法在标签数量为10、50、100的情况下的冲突次数、通信时间以及平均每个标签的识别市场。可以看出，查询二进制树的平均时长均大于ALOHA算法，并且随着标签数的增长，单个标签识别所需要的时长更长，从而能够看出ALOHA算法相较于查询二进制树算法更加高效。</p><h2 id="实验心得">实验心得</h2><p>在这次实验中，我们深入学习并了解到了基于ALOHA算法与查询二进制树算法的基本原理，了解了在实际通信情况下可能会发生的冲突以及可以选择的解决方法，并根据不同算法原理仿真模拟出在实际通信情况下的两种算法的识别效率，加强了我们对这两种算法的理解。此外，我们还能够通过对比两种算法对于相同数量的通信信号的处理效率，来分析其算法的优劣，同时也能够加以完善，让我们对于这些问题的印象更加深刻，有助于我们学习、分析、了解并实现更多相似的算法及其原理。此外，本次实验还大大强化了我对于python语言的掌握，之前对于python语言的学习仅局限于解决一些具体的数学问题，类似于计算题。而本次实验则是将我们学习的各种方法融合起来，共同实现一个具体的需求，更像一个应用题，这也让我收获颇丰。</p><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-实验目的和要求&quot;&gt;1. 实验目的和要求&lt;/h2&gt;
&lt;p&gt;（1） 掌握RFID工作原理&lt;/p&gt;
&lt;p&gt;（2）掌握RFID标签冲突产生原理&lt;/p&gt;
&lt;p&gt;（3）掌握常见的RFID防冲突识别算法&lt;/p&gt;
&lt;p&gt;（4）对常见的RFID防冲突识别算法进行实验比较&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="实验报告" scheme="https://elementgc.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
    <category term="邮政物联网技术与应用" scheme="https://elementgc.github.io/tags/%E9%82%AE%E6%94%BF%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用的github命令</title>
    <link href="https://elementgc.github.io/2023/05/23/usual-git-command/"/>
    <id>https://elementgc.github.io/2023/05/23/usual-git-command/</id>
    <published>2023-05-23T13:18:04.828Z</published>
    <updated>2023-06-02T06:25:35.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="针对本地仓库的操作">针对本地仓库的操作</h2><h3 id="初级的git命令">初级的git命令</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>git init</strong>：<strong>初始化</strong>本地仓库（创建新仓库）</p></li><li class="lvl-2"><p><strong>git clone</strong>：拷贝一份远程仓库，也就是<strong>下载一个项目</strong>。</p></li><li class="lvl-2"><p><strong>git status</strong>：查看仓库<strong>当前的状态</strong>，显示有变更的文件。</p></li><li class="lvl-2"><p><strong>git add</strong>：添加文件到暂存区（缓存区）</p></li><li class="lvl-2"><p><strong>git commit</strong>：提交暂存区到本地仓库。</p></li><li class="lvl-2"><p><strong>git push</strong>：上传本地仓库到远程仓库并合并。</p></li><li class="lvl-2"><p><strong>git pull</strong>：下载远程仓库到本地仓库并合并。</p></li><li class="lvl-2"><p><strong>git branch</strong>：显示本地分支或创建新<strong>分支。</strong></p></li><li class="lvl-2"><p><strong>git checkout</strong>：切换分支或检出文件。</p></li><li class="lvl-2"><p><strong>git merge</strong>：合并分支。</p></li><li class="lvl-2"><p><strong>git log</strong>：查看提交日志。</p></li><li class="lvl-2"><p><strong>git diff</strong>：比较文件的不同。</p></li><li class="lvl-2"><p><strong>git reset</strong>：回退版本。</p></li><li class="lvl-2"><p><strong>git rm</strong>：删除文件。</p></li><li class="lvl-2"><p><strong>git mv</strong>：移动或重命名文件。</p><hr></li></ul><h3 id="下载文件">下载文件</h3><h4 id="git-pull-与-git-clone辨析">git pull 与 git clone辨析</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>git clone</strong>是在本地没有仓库的时候，从远程仓库克隆整个仓库到本地，包括所有的分支、标签、提交历史等。它是一个从无到有的过程，不需要先初始化本地仓库。例如，你可以使用以下命令克隆一个远程仓库到本地：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tensorflow/tensorflow.git</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>git pull</strong>是在本地有仓库的情况下，从远程仓库获取最新的版本，并与本地分支合并。它相当于先执行<code>git fetch</code>，然后再执行<code>git merge</code>。例如，你可以使用以下命令拉取远程master分支的最新版本，并与本地master分支合并：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>git clone</strong>和<strong>git pull</strong>的主要区别是：<strong>git clone</strong>只需要执行一次，就可以在本地创建一个完整的远程仓库的副本；而<strong>git pull</strong>需要在本地已经存在一个远程仓库的副本的基础上，定期执行，以保持本地和远程的同步。</p></li></ul><h4 id="gitclone-使用时的注意事项">gitclone 使用时的注意事项</h4><ul class="lvl-0"><li class="lvl-2"><p>git clone默认是克隆远程仓库的master分支，也就是HEAD指向的分支。如果你想确定下载下来的是哪一个分支，你可以使用以下命令查看：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>这个命令会显示本地和远程的所有分支，你可以看到当前分支有一个星号（*）标记，通常是master分支。你也可以看到远程仓库的其他分支，它们的前缀是<code>remotes/origin/</code>。</p><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">如果运行时你的<code>git bash</code>显示的是</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br></pre></td></tr></table></figure><p>那就说明你<strong>还没有进入到</strong>克隆的仓库的文件夹中，建议返回文件夹看看（别老盯着你那破小黑屏啦）</p><ul class="lvl-0"><li class="lvl-2"><p>如果你想克隆远程仓库的其他分支，而不是默认的master分支，你可以使用以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branchname&gt; &lt;remote-repo-url&gt;</span><br></pre></td></tr></table></figure><p>这个命令会克隆指定的分支，并自动切换到该分支。例如，你可以使用以下命令克隆远程仓库的dev分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/tensorflow/tensorflow.git</span><br></pre></td></tr></table></figure><hr><h3 id="分支操作">分支操作</h3><h4 id="git-branch–单分支操作">git branch–单分支操作</h4><p>git branch是对于分支的操作的一个命令。它有很多常用的操作，例如：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>git branch</strong>：不带参数时，可以列出<strong>本地的所有</strong>分支，当前分支有一个星号（*）标记¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -a</strong>：可以列出<strong>本地和远程</strong>的所有分支，远程分支的前缀是<code>remotes/origin/</code>²³。</p></li><li class="lvl-2"><p><strong>git branch &lt;分支名&gt;</strong>：可以<strong>创建</strong>一个新的分支，基于当前分支的最新提交¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -d &lt;分支名&gt;</strong>：可以<strong>删除</strong>一个本地分支，前提是该分支已经被合并到其他分支¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -D &lt;分支名&gt;</strong>：可以<em>强制删除</em>一个本地分支，即使该分支没有被合并到其他分支¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -m &lt;原分支名&gt; &lt;新分支名&gt;</strong>：可以<strong>重命名</strong>一个本地分支，如果新分支名已经存在，会报错¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch -M &lt;原分支名&gt; &lt;新分支名&gt;</strong>：可以<em>强制重命名</em>一个本地分支，如果新分支名已经存在，会覆盖它¹²⁴。</p></li><li class="lvl-2"><p><strong>git branch --set-upstream-to=origin/&lt;远程分支名&gt; &lt;本地分支名&gt;</strong>：可以设置本地分支和远程分支的关联关系，方便执行pull和push操作³⁵。</p></li></ul><p>举例说明：</p><ul class="lvl-0"><li class="lvl-2"><p>假设我们要在本地<strong>创建一个叫做dev的新分支，并切换到该分支</strong>，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>或者使用快捷方式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要删除dev这个本地分支，并且它已经被合并到master分支，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev这个本地分支重命名为feature，并且覆盖掉已经存在的feature分支，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -M dev feature</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要设置feature这个本地分支和origin/feature这个远程分支的关联关系，我们可以执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git branch --set-upstream-to=origin/feature</span><br></pre></td></tr></table></figure><h4 id="多分支操作–分支合并">多分支操作–分支合并</h4><p>分支合并是指将两个或多个不同的分支的代码合并到一起，形成一个新的分支或更新一个已有的分支¹²。分支合并可以让我们在不同的开发环境中做事，并来回切换，也可以让我们将不同的功能或修复合并到主线上¹。</p><p>实现分支合并的主要命令是<strong>git merge</strong>，它可以将任何分支合并到当前分支中去¹²⁴。例如，如果我们要将dev分支合并到master分支，我们可以执行以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>这样就会在master分支上创建一个新的提交节点，记录这次合并的结果¹²⁴。</p><p>进行分支合并的时候，需要注意以下几点：</p><ul class="lvl-0"><li class="lvl-2"><p>分支合并可能会产生<strong>冲突</strong>，即两个分支对同一个文件的同一个地方做了不同的修改¹²⁴。这时候，git无法自动完成合并，需要我们手动解决冲突，并重新提交¹²⁴。</p></li><li class="lvl-2"><p>分支合并有不同的<strong>策略</strong>，例如fast-forward、recursive、ours、theirs等¹³。不同的策略会影响合并的结果和历史记录¹³。默认情况下，git会自动选择合适的策略，但我们也可以用**-s**选项来指定策略¹³。</p></li><li class="lvl-2"><p>分支合并之前，最好先更新本地和远程的代码，以保证代码是最新的²。我们可以用<strong>git pull</strong>命令来拉取远程仓库的代码，并自动合并到本地分支²⁴。</p></li></ul><h4 id="git-merge与git-checkout-其他用法的解析">git merge与git checkout 其他用法的解析</h4><p>git merge 和 git checkout 这两个命令除了用于分支合并和切换之外，还有一些其他的功能：</p><p><strong>git merge</strong>的其他功能：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>git merge --abort</strong>：可以取消正在进行的合并操作，恢复到合并之前的状态¹²。这个命令在遇到合并冲突时很有用，可以让你重新选择合并策略或者放弃合并¹²。</p></li><li class="lvl-2"><p><strong>git merge --squash</strong>：可以将目标分支的多个提交压缩成一个提交，然后合并到当前分支¹²。这个命令可以让你保持提交历史的简洁，避免过多的合并提交¹²。</p></li><li class="lvl-2"><p><strong>git merge --continue</strong>：可以在解决完合并冲突后，继续完成合并操作¹²。这个命令相当于执行了git add和git commit两个命令¹²。</p></li></ul><p>举例说明：</p><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev分支合并到master分支，但是发生了冲突，我们可以执行以下命令来取消合并：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev分支合并到master分支，但是dev分支有很多小的提交，我们可以执行以下命令来压缩成一个提交：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --squash dev</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们要将dev分支合并到master分支，发生了冲突，我们手动解决了冲突，我们可以执行以下命令来继续合并：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p><strong>git checkout</strong>的其他功能：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>git checkout &lt;文件名&gt;</strong>：可以将指定文件恢复到上一次提交的状态³ 。这个命令在你修改了文件但是不想保留修改时很有用³ 。</p></li><li class="lvl-2"><p><strong>git checkout <commit> &lt;文件名&gt;</commit></strong>：可以将指定文件恢复到指定提交的状态³ 。这个命令在你想回退某个文件到某个版本时很有用³ 。</p></li><li class="lvl-2"><p><strong>git checkout -b &lt;新分支名&gt;</strong>：可以<strong>创建一个新的分支，并切换到该分支</strong>³ 。这个命令相当于执行了git branch和git checkout两个命令³ 。</p></li></ul><p>举例说明：</p><ul class="lvl-0"><li class="lvl-2"><p>假设我们修改了index.html文件，但是不想保留修改，我们可以执行以下命令来恢复文件：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout index.html</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们想将index.html文件恢复到a123456这个提交的状态，我们可以执行以下命令来恢复文件：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout a123456 index.html</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>假设我们想创建一个新的分支feature，并切换到该分支，我们可以执行以下命令来创建和切换分支：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br></pre></td></tr></table></figure><h2 id="清空本地的Git关联的远程仓库（删库跑路本地版）">清空本地的Git关联的远程仓库（删库跑路本地版）</h2><ul class="lvl-0"><li class="lvl-2"><p>如果您想要删除本地仓库的所有文件、分支和提交，但<strong>保留</strong>远程仓库的链接，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要删除本地仓库的所有文件、分支和提交，并且<strong>断开</strong>远程仓库的链接，您可以直接删除本地仓库的目录，或者在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf *</span><br><span class="line"><span class="built_in">rm</span> -rf .git</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要保留本地仓库的部分文件、分支和提交，但重置到远程仓库的状态，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要清除本地仓库中未被Git跟踪的文件，如包、配置、日志等，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git clean -d --force</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果您想要删除本地仓库关联的远程仓库，您可以在本地仓库的目录中执行以下命令：</p></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><h2 id="转载声明">转载声明</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;针对本地仓库的操作&quot;&gt;针对本地仓库的操作&lt;/h2&gt;
&lt;h3 id=&quot;初级的git命令&quot;&gt;初级的git命令&lt;/h3&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;git init&lt;/strong&gt;：&lt;strong</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="git" scheme="https://elementgc.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://elementgc.github.io/2023/05/23/hello-world/"/>
    <id>https://elementgc.github.io/2023/05/23/hello-world/</id>
    <published>2023-05-23T12:12:58.294Z</published>
    <updated>2023-05-26T07:56:35.573Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="教程" scheme="https://elementgc.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
