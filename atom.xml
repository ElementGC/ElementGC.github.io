<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心有所向，日复一日，必有精进</title>
  
  <subtitle>欢迎来到ELement_GC的咸鱼博客</subtitle>
  <link href="https://elementgc.github.io/atom.xml" rel="self"/>
  
  <link href="https://elementgc.github.io/"/>
  <updated>2023-05-24T04:58:31.157Z</updated>
  <id>https://elementgc.github.io/</id>
  
  <author>
    <name>Element_GC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RFID anti-collision algorithm</title>
    <link href="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/"/>
    <id>https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/</id>
    <published>2023-05-24T03:47:14.099Z</published>
    <updated>2023-05-24T04:58:31.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实验目的和要求"><a href="#1-实验目的和要求" class="headerlink" title="1. 实验目的和要求"></a>1. 实验目的和要求</h2><p>（1） 掌握RFID工作原理</p><p>（2）掌握RFID标签冲突产生原理</p><p>（3）掌握常见的RFID防冲突识别算法</p><p>（4）对常见的RFID防冲突识别算法进行实验比较</p><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2. 实验环境"></a>2. 实验环境</h2><p>使用Python语言进行代码的编译与运行，<code>python</code>版本为<code>3.9.13</code><br>使用的集成开发环境IDE为<code>Pycharm</code>，版本为<code>17.0.5</code><br>完成实验所需要的数据包为：<br><code>random</code>数据包，用于生成随机数，分配时隙与标签</p><h2 id="3-实验原理"><a href="#3-实验原理" class="headerlink" title="3. 实验原理"></a>3. 实验原理</h2><h3 id="3-1-帧时隙ALOHA-FSA-RFID防冲突识别算法："><a href="#3-1-帧时隙ALOHA-FSA-RFID防冲突识别算法：" class="headerlink" title="3.1 帧时隙ALOHA(FSA) RFID防冲突识别算法："></a>3.1 帧时隙<code>ALOHA(FSA)</code> RFID防冲突识别算法：</h3><p>将<code>ALOHA</code>算法分为许多时隙，其中若干时隙为一帧，阅读器以帧为单位进行识别。在<code>FSA</code>算法中，每一帧开始时阅读器就广播帧的长度f，指明下一帧所包含的时隙个数，并激活识别区域中的所有标签。每个标签在接收到帧长f之后随机独立地在0~(f-1)中选择一个整数作为自己发送标识符的时隙序号，并将这个序号存在寄存器SN中。<br>在下一帧的每一个时隙中，阅读器通过时隙开始命令启动一个新的时隙，如果标签SN的值为零立即发送标识符号，如果不等于零，则将SN值减一并且不发送标识符。<br>对于标签而言，如果标识符发送成功（即无冲突），则该标签立即进入休眠状态，在之后的时隙中不再活动。如果有冲突发生，则该标签进入等待状态，在下一帧中重新选择一个时隙发送标识符。<br>阅读器不断重复以上过程，直到在某一帧中没有收到任何标签信号，则认为所有标签均被识别。基于上述原理，我们可以得知在FSA算法中存在三种状态的时隙：</p><p>（1）空时隙，即没有标签相应；</p><p>（2）单时隙，即只有一个标签相应；</p><p>（3）冲突时隙，即不只一个标签相应，发生冲突。当且仅当在单时隙中时，阅读器才能成功识别一个标签。<br>我们可以设计出FSA算法流程如下所示：</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/p1.png" alt="图1. FSA算法流程图"></p><h3 id="3-2-基于查询二进制树的防冲突算法"><a href="#3-2-基于查询二进制树的防冲突算法" class="headerlink" title="3.2 基于查询二进制树的防冲突算法"></a>3.2 基于查询二进制树的防冲突算法</h3><p>每个标签需要维持一个计数器，计数器初始值为0。在每个时隙开始时，如果标签的计数器为0则立即发送自己的标识符号，否则该时隙不响应。标签识别成功，进入沉默状态，每个时隙结束时阅读器会将接收到的时隙状态反馈给标签，场内的标签根据结束时阅读器反的结果对自己维持的计数器进行调整。<br>因此，对于是否冲突两种情况，也需要做出对应的判断：</p><ol><li>冲突时隙：参与响应的标签从0&#x2F;1中随机选择一个，将其加到自己的计数器上；没有参与的标签计数器加1。由此可以将冲突的标签分为两个集合。</li><li>没有冲突：单时隙，成功识别，进入沉默状态，没有被识别的标签自己减1</li></ol><h2 id="4-实验步骤（包含结果分析和源代码）"><a href="#4-实验步骤（包含结果分析和源代码）" class="headerlink" title="4. 实验步骤（包含结果分析和源代码）"></a>4. 实验步骤（包含结果分析和源代码）</h2><h3 id="4-1-帧时隙ALOHA（FSA）RFID防冲突识别算法"><a href="#4-1-帧时隙ALOHA（FSA）RFID防冲突识别算法" class="headerlink" title="4.1 帧时隙ALOHA（FSA）RFID防冲突识别算法:"></a>4.1 帧时隙ALOHA（FSA）RFID防冲突识别算法:</h3><h4 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 帧参数设置</span></span><br><span class="line">tatal = <span class="number">100</span>  <span class="comment"># 发送时间范围</span></span><br><span class="line">length = <span class="number">1</span>  <span class="comment"># 帧长</span></span><br><span class="line">solt = <span class="number">1</span>  <span class="comment"># 时隙</span></span><br><span class="line">num = <span class="number">100</span>  <span class="comment"># 总帧数</span></span><br><span class="line"><span class="built_in">list</span> = []  <span class="comment"># 用来存放每一个数据帧</span></span><br><span class="line"><span class="comment"># 定义帧类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Frame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, time</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 帧的名字</span></span><br><span class="line">        self.send_time = time  <span class="comment"># 帧的发送时间</span></span><br><span class="line"><span class="comment"># 随机产生每个帧的发送时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="comment"># 帧的名字用序号代替，发送时间都是整数</span></span><br><span class="line">    name = i</span><br><span class="line">    send_time = random.randrange(<span class="number">0</span>, tatal + <span class="number">1</span>, solt)</span><br><span class="line">    frame = Frame(name, send_time)</span><br><span class="line">    <span class="built_in">list</span>.append(frame)</span><br><span class="line"><span class="comment"># 按发送时间属性排序(按时间发送)</span></span><br><span class="line"><span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x.send_time)  <span class="comment"># lambda定义了一个隐含函数x,该函数返回send_time属性</span></span><br><span class="line">success = <span class="number">0</span>  <span class="comment"># 成功发送帧的数量</span></span><br><span class="line">send_frame = [] <span class="comment">#成功发送帧的集合</span></span><br><span class="line">conflict = <span class="number">0</span>  <span class="comment"># 发生冲突即本轮传输失败的帧数量</span></span><br><span class="line"><span class="comment"># 有帧发送、并且发送时间在通信时间内才发送</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">list</span>) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">list</span>[<span class="number">0</span>].send_time &lt;= tatal:</span><br><span class="line">    current_frame = <span class="built_in">list</span>[<span class="number">0</span>]  <span class="comment"># 当前帧一直都是list[0]</span></span><br><span class="line">    <span class="comment"># 冲突检测</span></span><br><span class="line">    address = []  <span class="comment"># 存放冲突帧的name</span></span><br><span class="line">    <span class="comment"># 所有冲突帧存储到address,没有则len(address)=1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">list</span>[i].send_time == current_frame.send_time:</span><br><span class="line">            address.append(i)</span><br><span class="line">    <span class="comment"># 没有冲突,移除列表，同时成功发送帧数量加1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(address) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">list</span>.remove(current_frame)</span><br><span class="line">        send_frame.append(current_frame)</span><br><span class="line">        success += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 发生冲突</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> address:</span><br><span class="line">            <span class="built_in">list</span>[i].send_time += random.randint(<span class="number">1</span>, tatal + <span class="number">1</span>) * solt  <span class="comment"># 延迟发送时间k个时隙</span></span><br><span class="line">        conflict += <span class="number">1</span>  <span class="comment"># 冲突帧的数量加1</span></span><br><span class="line">        <span class="built_in">list</span>.sort(key=<span class="keyword">lambda</span> x: x.send_time)  <span class="comment"># 重新排序</span></span><br><span class="line">        address.clear()</span><br><span class="line"><span class="comment"># 计算吞吐率</span></span><br><span class="line">z = success / num</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通信时间:&quot;</span>, tatal, <span class="string">&quot;帧长:&quot;</span>, length)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成功发送的帧数量:<span class="subst">&#123;success&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;发送的帧总数量:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;冲突次数:<span class="subst">&#123;conflict&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;吞吐率:<span class="subst">&#123;z*<span class="number">100</span>&#125;</span>%&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;发送成功的帧分别为&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(send_frame)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;编号：<span class="subst">&#123;send_frame[i].name&#125;</span>；时间：<span class="subst">&#123;send_frame[i].send_time&#125;</span>&quot;</span>,end=<span class="string">&quot;\t\t&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">6</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果及分析："><a href="#运行结果及分析：" class="headerlink" title="运行结果及分析："></a>运行结果及分析：</h4><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/51c9ddb7c4457818d0ef6ae0c5be0fd4.png" alt="截图"></p><p>在代码运行的过程中，我们对发生冲突的次数进行了统计，观察并记录在规定的时间内（即一定的循环次数内）能够成功发送的帧及其数量，并作为结果进行输出。可以看出，在一定的通信时长内，同样数量的帧总是会发生冲突，导致无法及时完全发送出去，吞吐率往往不及一半。</p><h3 id="4-2-基于查询二进制树的防冲突算法"><a href="#4-2-基于查询二进制树的防冲突算法" class="headerlink" title="4.2 基于查询二进制树的防冲突算法"></a>4.2 基于查询二进制树的防冲突算法</h3><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 帧参数设置</span></span><br><span class="line">num = <span class="number">10</span>  <span class="comment"># 总标签数</span></span><br><span class="line"><span class="built_in">list</span> = []  <span class="comment"># 用来存放每一个标签</span></span><br><span class="line">conflict = <span class="number">0</span>  <span class="comment"># 发生冲突即本轮传输失败的帧数量</span></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"><span class="comment"># 定义帧类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name  <span class="comment"># 标签名</span></span><br><span class="line">        self.timer = [<span class="number">0</span>]  <span class="comment"># 计数器</span></span><br><span class="line">        self.active = <span class="number">1</span> <span class="comment"># 活跃状态</span></span><br><span class="line"><span class="comment">#检查计数器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Check_Timer</span>(<span class="params">timerA,timerB</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(timerA)):</span><br><span class="line">        <span class="keyword">if</span> timerA[i] != timerB[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#查询二进制树主程序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Check_Lable</span>(<span class="params">boarder,<span class="built_in">list</span></span>):</span><br><span class="line">    same = []</span><br><span class="line">    <span class="keyword">global</span> times</span><br><span class="line">    times += <span class="number">1</span></span><br><span class="line">    insame = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="comment"># if list[i].active : #仅对活跃的标签进行检测</span></span><br><span class="line">        issame = Check_Timer(boarder,<span class="built_in">list</span>[i].timer)</span><br><span class="line">        <span class="keyword">if</span> issame:<span class="comment">#前缀相同,则重新加前缀，记录在案</span></span><br><span class="line">            <span class="built_in">list</span>[i].timer.insert(<span class="number">0</span>,random.randint(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            same.append(<span class="built_in">list</span>[i])</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#前缀不同，另做一个集合</span></span><br><span class="line">            insame.append(<span class="built_in">list</span>[i])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(same) == <span class="number">1</span>:  <span class="comment">#只有一个重复的，就说明这个标签确定对上了</span></span><br><span class="line">        same[<span class="number">0</span>].active = <span class="number">0</span></span><br><span class="line">        same[<span class="number">0</span>].timer.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(same) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment">#前缀加0.继续进行</span></span><br><span class="line">        boarder.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        Check_Lable(boarder,same)<span class="comment"># 冲突的标签拉进去</span></span><br><span class="line">        boarder.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(insame) != <span class="number">0</span>:</span><br><span class="line">        boarder[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        Check_Lable(boarder, insame)</span><br><span class="line"><span class="comment"># 生成每一帧及其计数器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="comment"># 标签的名字用序号代替，发送时间都是整数</span></span><br><span class="line">    name = i</span><br><span class="line">    frame = Lable(name)</span><br><span class="line">    <span class="built_in">list</span>.append(frame)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">fin_res = Check_Lable([<span class="number">0</span>],<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># times = fin_res</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;本次执行共有<span class="subst">&#123;num&#125;</span>个标签&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总共执行次数为<span class="subst">&#123;times&#125;</span>次&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;各个标签的位置分别为:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;序号：<span class="subst">&#123;<span class="built_in">list</span>[i].name&#125;</span>——二进制树坐标：<span class="subst">&#123;<span class="built_in">list</span>[i].timer&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果及分析"><a href="#运行结果及分析" class="headerlink" title="运行结果及分析"></a>运行结果及分析</h4><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/51c9ddb7c4457818d0ef6ae0c5be0fd4.png" alt="截图"></p><p>在该代码中，我们通过类似于构造二叉树的方法建立二进制树，每一帧都进行一次广播并查找有无坐标（即计数器）重复项，若有，则对重复项随机添加前缀并再次广播，直到将全部重复项都区分开来，才算完成，并退回到上一层，就这样逐步分化，最终形成二进制树。</p><h3 id="4-3-分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别"><a href="#4-3-分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别" class="headerlink" title="4.3 分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别"></a>4.3 分别构造包含标签数量为10、50、100的标签集合，并使用上述两种算法进行标签识别</h3><p>(1) 10个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/43ad20432a2b06f48db8c753abbcb2d0.png" alt="截图"></p><p>(2)50个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/55af6df94a09600c826ff703c553fe2e.png" alt="截图"></p><p>(3)100个标签</p><p><img src="https://elementgc.github.io/2023/05/24/RFID-anti-collision-lgorithm/099e634ca983336eb2863456258b8199.png" alt="截图"></p><h3 id="4-4-数据表格绘制"><a href="#4-4-数据表格绘制" class="headerlink" title="4.4 数据表格绘制"></a>4.4 数据表格绘制</h3><table border="2px solid #000" cellspacing="0" cellpadding="0" width="100%" bordercolor="black" bgcolor="white">    <tr>        <th>标签数量</th>        <th>ALOHA算法</th>        <th>查询二进制树</th>        <th>运行结果</th>    </tr>    <tr align="center">        <td rowspan="3">10</td>        <td>3</td>        <td>10</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>13</td>        <td>20</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>1.3</td>        <td>2</td>        <td>平均识别时长</td>    </tr>    <tr align="center">        <td rowspan="3">50</td>        <td>52</td>        <td>63</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>102</td>        <td>121</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>2.04</td>        <td>2.42</td>        <td>平均识别时长</td>    </tr>    <tr align="center">        <td rowspan="3">100</td>        <td>76</td>        <td>149</td>        <td>冲突次数</td>    </tr>    <tr align="center">        <td>176</td>        <td>272</td>        <td>通信时间</td>    </tr>    <tr align="center">        <td>1.76</td>        <td>2.72</td>        <td>平均识别时长</td>    </tr></table><h3 id="4-5-算法分析"><a href="#4-5-算法分析" class="headerlink" title="4.5 算法分析"></a>4.5 算法分析</h3><p>如表格所示。我们分别统计并计算了ALOHA算法与查询二进制树算法在标签数量为10、50、100的情况下的冲突次数、通信时间以及平均每个标签的识别市场。可以看出，查询二进制树的平均时长均大于ALOHA算法，并且随着标签数的增长，单个标签识别所需要的时长更长，从而能够看出ALOHA算法相较于查询二进制树算法更加高效。</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>在这次实验中，我们深入学习并了解到了基于ALOHA算法与查询二进制树算法的基本原理，了解了在实际通信情况下可能会发生的冲突以及可以选择的解决方法，并根据不同算法原理仿真模拟出在实际通信情况下的两种算法的识别效率，加强了我们对这两种算法的理解。此外，我们还能够通过对比两种算法对于相同数量的通信信号的处理效率，来分析其算法的优劣，同时也能够加以完善，让我们对于这些问题的印象更加深刻，有助于我们学习、分析、了解并实现更多相似的算法及其原理。<br>此外，本次实验还大大强化了我对于python语言的掌握，之前对于python语言的学习仅局限于解决一些具体的数学问题，类似于计算题。而本次实验则是将我们学习的各种方法融合起来，共同实现一个具体的需求，更像一个应用题，这也让我收获颇丰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-实验目的和要求&quot;&gt;&lt;a href=&quot;#1-实验目的和要求&quot; class=&quot;headerlink&quot; title=&quot;1. 实验目的和要求&quot;&gt;&lt;/a&gt;1. 实验目的和要求&lt;/h2&gt;&lt;p&gt;（1） 掌握RFID工作原理&lt;/p&gt;
&lt;p&gt;（2）掌握RFID标签冲突产生原理&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git 常用指令小合集</title>
    <link href="https://elementgc.github.io/2023/05/23/usual-git-command/"/>
    <id>https://elementgc.github.io/2023/05/23/usual-git-command/</id>
    <published>2023-05-23T13:18:04.828Z</published>
    <updated>2023-05-23T13:21:03.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清空本地的Git关联的远程仓库（删库跑路）"><a href="#清空本地的Git关联的远程仓库（删库跑路）" class="headerlink" title="清空本地的Git关联的远程仓库（删库跑路）"></a>清空本地的Git关联的远程仓库（删库跑路）</h2><ul><li>如果您想要删除本地仓库的所有文件、分支和提交，但<strong>保留</strong>远程仓库的链接，您可以在本地仓库的目录中执行以下命令¹：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>如果您想要删除本地仓库的所有文件、分支和提交，并且<strong>断开</strong>远程仓库的链接，您可以直接删除本地仓库的目录，或者在本地仓库的目录中执行以下命令：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf *</span><br><span class="line"><span class="built_in">rm</span> -rf .git</span><br></pre></td></tr></table></figure><ul><li>如果您想要保留本地仓库的部分文件、分支和提交，但重置到远程仓库的状态，您可以在本地仓库的目录中执行以下命令³：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><ul><li>如果您想要清除本地仓库中未被Git跟踪的文件，如包、配置、日志等，您可以在本地仓库的目录中执行以下命令⁴：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -d --force</span><br></pre></td></tr></table></figure><ul><li>如果您想要删除本地仓库关联的远程仓库，您可以在本地仓库的目录中执行以下命令：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><h2 id="针对本地仓库的操作"><a href="#针对本地仓库的操作" class="headerlink" title="针对本地仓库的操作"></a>针对本地仓库的操作</h2><h3 id="初级的git命令"><a href="#初级的git命令" class="headerlink" title="初级的git命令"></a>初级的git命令</h3><ul><li><p><strong>git init</strong>：<strong>初始化</strong>本地仓库（创建新仓库）</p></li><li><p><strong>git clone</strong>：拷贝一份远程仓库，也就是<strong>下载一个项目</strong>。</p></li><li><p><strong>git status</strong>：查看仓库<strong>当前的状态</strong>，显示有变更的文件。</p></li><li><p><strong>git add</strong>：添加文件到暂存区（缓存区）</p></li><li><p><strong>git commit</strong>：提交暂存区到本地仓库。</p></li><li><p><strong>git push</strong>：上传本地仓库到远程仓库并合并。</p></li><li><p><strong>git pull</strong>：下载远程仓库到本地仓库并合并。</p></li><li><p><strong>git branch</strong>：显示本地分支或创建新<strong>分支。</strong></p></li><li><p><strong>git checkout</strong>：切换分支或检出文件。</p></li><li><p><strong>git merge</strong>：合并分支。</p></li><li><p><strong>git log</strong>：查看提交日志。</p></li><li><p><strong>git diff</strong>：比较文件的不同。</p></li><li><p><strong>git reset</strong>：回退版本。</p></li><li><p><strong>git rm</strong>：删除文件。</p></li><li><p><strong>git mv</strong>：移动或重命名文件。</p><hr></li></ul><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><h4 id="git-pull-与-git-clone辨析"><a href="#git-pull-与-git-clone辨析" class="headerlink" title="git pull 与 git clone辨析"></a>git pull 与 git clone辨析</h4><ul><li><strong>git clone</strong>是在本地没有仓库的时候，从远程仓库克隆整个仓库到本地，包括所有的分支、标签、提交历史等。它是一个从无到有的过程，不需要先初始化本地仓库。例如，你可以使用以下命令克隆一个远程仓库到本地：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tensorflow/tensorflow.git</span><br></pre></td></tr></table></figure><ul><li><strong>git pull</strong>是在本地有仓库的情况下，从远程仓库获取最新的版本，并与本地分支合并。它相当于先执行<code>git fetch</code>，然后再执行<code>git merge</code>。例如，你可以使用以下命令拉取远程master分支的最新版本，并与本地master分支合并：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><ul><li><strong>git clone</strong>和<strong>git pull</strong>的主要区别是：<strong>git clone</strong>只需要执行一次，就可以在本地创建一个完整的远程仓库的副本；而<strong>git pull</strong>需要在本地已经存在一个远程仓库的副本的基础上，定期执行，以保持本地和远程的同步。</li></ul><h4 id="gitclone-使用时的注意事项"><a href="#gitclone-使用时的注意事项" class="headerlink" title="gitclone 使用时的注意事项"></a>gitclone 使用时的注意事项</h4><ul><li>git clone默认是克隆远程仓库的master分支，也就是HEAD指向的分支。如果你想确定下载下来的是哪一个分支，你可以使用以下命令查看：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>这个命令会显示本地和远程的所有分支，你可以看到当前分支有一个星号（*）标记，通常是master分支。你也可以看到远程仓库的其他分支，它们的前缀是<code>remotes/origin/</code>。</p><ul><li><ul><li>如果运行时你的<code>git bash</code>显示的是</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br></pre></td></tr></table></figure><p>那就说明你<strong>还没有进入到</strong>克隆的仓库的文件夹中，建议返回文件夹看看（别老盯着你那破小黑屏啦）</p><ul><li>如果你想克隆远程仓库的其他分支，而不是默认的master分支，你可以使用以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b &lt;branchname&gt; &lt;remote-repo-url&gt;</span><br></pre></td></tr></table></figure><p>这个命令会克隆指定的分支，并自动切换到该分支。例如，你可以使用以下命令克隆远程仓库的dev分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b dev https://github.com/tensorflow/tensorflow.git</span><br></pre></td></tr></table></figure><hr><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="git-branch–单分支操作"><a href="#git-branch–单分支操作" class="headerlink" title="git branch–单分支操作"></a>git branch–单分支操作</h4><p>git branch是对于分支的操作的一个命令。它有很多常用的操作，例如：</p><ul><li><strong>git branch</strong>：不带参数时，可以列出<strong>本地的所有</strong>分支，当前分支有一个星号（*）标记¹²⁴。</li><li><strong>git branch -a</strong>：可以列出<strong>本地和远程</strong>的所有分支，远程分支的前缀是<code>remotes/origin/</code>²³。</li><li><strong>git branch &lt;分支名&gt;<strong>：可以</strong>创建</strong>一个新的分支，基于当前分支的最新提交¹²⁴。</li><li><strong>git branch -d &lt;分支名&gt;<strong>：可以</strong>删除</strong>一个本地分支，前提是该分支已经被合并到其他分支¹²⁴。</li><li>**git branch -D &lt;分支名&gt;*<em>：可以</em>强制删除*一个本地分支，即使该分支没有被合并到其他分支¹²⁴。</li><li><strong>git branch -m &lt;原分支名&gt; &lt;新分支名&gt;<strong>：可以</strong>重命名</strong>一个本地分支，如果新分支名已经存在，会报错¹²⁴。</li><li>**git branch -M &lt;原分支名&gt; &lt;新分支名&gt;*<em>：可以</em>强制重命名*一个本地分支，如果新分支名已经存在，会覆盖它¹²⁴。</li><li>**git branch –set-upstream-to&#x3D;origin&#x2F;&lt;远程分支名&gt; &lt;本地分支名&gt;**：可以设置本地分支和远程分支的关联关系，方便执行pull和push操作³⁵。</li></ul><p>举例说明：</p><ul><li>假设我们要在本地<strong>创建一个叫做dev的新分支，并切换到该分支</strong>，我们可以执行以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>或者使用快捷方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><ul><li>假设我们要删除dev这个本地分支，并且它已经被合并到master分支，我们可以执行以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><ul><li>假设我们要将dev这个本地分支重命名为feature，并且覆盖掉已经存在的feature分支，我们可以执行以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M dev feature</span><br></pre></td></tr></table></figure><ul><li>假设我们要设置feature这个本地分支和origin&#x2F;feature这个远程分支的关联关系，我们可以执行以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git branch --set-upstream-to=origin/feature</span><br></pre></td></tr></table></figure><h4 id="多分支操作–分支合并"><a href="#多分支操作–分支合并" class="headerlink" title="多分支操作–分支合并"></a>多分支操作–分支合并</h4><p>分支合并是指将两个或多个不同的分支的代码合并到一起，形成一个新的分支或更新一个已有的分支¹²。分支合并可以让我们在不同的开发环境中做事，并来回切换，也可以让我们将不同的功能或修复合并到主线上¹。</p><p>实现分支合并的主要命令是<strong>git merge</strong>，它可以将任何分支合并到当前分支中去¹²⁴。例如，如果我们要将dev分支合并到master分支，我们可以执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p>这样就会在master分支上创建一个新的提交节点，记录这次合并的结果¹²⁴。</p><p>进行分支合并的时候，需要注意以下几点：</p><ul><li>分支合并可能会产生<strong>冲突</strong>，即两个分支对同一个文件的同一个地方做了不同的修改¹²⁴。这时候，git无法自动完成合并，需要我们手动解决冲突，并重新提交¹²⁴。</li><li>分支合并有不同的<strong>策略</strong>，例如fast-forward、recursive、ours、theirs等¹³。不同的策略会影响合并的结果和历史记录¹³。默认情况下，git会自动选择合适的策略，但我们也可以用**-s**选项来指定策略¹³。</li><li>分支合并之前，最好先更新本地和远程的代码，以保证代码是最新的²。我们可以用<strong>git pull</strong>命令来拉取远程仓库的代码，并自动合并到本地分支²⁴。</li></ul><h4 id="git-merge与git-checkout-其他用法的解析"><a href="#git-merge与git-checkout-其他用法的解析" class="headerlink" title="git merge与git checkout 其他用法的解析"></a>git merge与git checkout 其他用法的解析</h4><p>git merge 和 git checkout 这两个命令除了用于分支合并和切换之外，还有一些其他的功能：</p><p><strong>git merge</strong>的其他功能：</p><ul><li><strong>git merge –abort</strong>：可以取消正在进行的合并操作，恢复到合并之前的状态¹²。这个命令在遇到合并冲突时很有用，可以让你重新选择合并策略或者放弃合并¹²。</li><li><strong>git merge –squash</strong>：可以将目标分支的多个提交压缩成一个提交，然后合并到当前分支¹²。这个命令可以让你保持提交历史的简洁，避免过多的合并提交¹²。</li><li><strong>git merge –continue</strong>：可以在解决完合并冲突后，继续完成合并操作¹²。这个命令相当于执行了git add和git commit两个命令¹²。</li></ul><p>举例说明：</p><ul><li>假设我们要将dev分支合并到master分支，但是发生了冲突，我们可以执行以下命令来取消合并：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><ul><li>假设我们要将dev分支合并到master分支，但是dev分支有很多小的提交，我们可以执行以下命令来压缩成一个提交：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --squash dev</span><br></pre></td></tr></table></figure><ul><li>假设我们要将dev分支合并到master分支，发生了冲突，我们手动解决了冲突，我们可以执行以下命令来继续合并：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --continue</span><br></pre></td></tr></table></figure><p><strong>git checkout</strong>的其他功能：</p><ul><li>**git checkout &lt;文件名&gt;**：可以将指定文件恢复到上一次提交的状态³ 。这个命令在你修改了文件但是不想保留修改时很有用³ 。</li><li>**git checkout <commit> &lt;文件名&gt;**：可以将指定文件恢复到指定提交的状态³ 。这个命令在你想回退某个文件到某个版本时很有用³ 。</li><li><strong>git checkout -b &lt;新分支名&gt;<strong>：可以</strong>创建一个新的分支，并切换到该分支</strong>³ 。这个命令相当于执行了git branch和git checkout两个命令³ 。</li></ul><p>举例说明：</p><ul><li>假设我们修改了index.html文件，但是不想保留修改，我们可以执行以下命令来恢复文件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout index.html</span><br></pre></td></tr></table></figure><ul><li>假设我们想将index.html文件恢复到a123456这个提交的状态，我们可以执行以下命令来恢复文件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout a123456 index.html</span><br></pre></td></tr></table></figure><ul><li>假设我们想创建一个新的分支feature，并切换到该分支，我们可以执行以下命令来创建和切换分支：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;清空本地的Git关联的远程仓库（删库跑路）&quot;&gt;&lt;a href=&quot;#清空本地的Git关联的远程仓库（删库跑路）&quot; class=&quot;headerlink&quot; title=&quot;清空本地的Git关联的远程仓库（删库跑路）&quot;&gt;&lt;/a&gt;清空本地的Git关联的远程仓库（删库跑路）&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://elementgc.github.io/2023/05/23/hello-world/"/>
    <id>https://elementgc.github.io/2023/05/23/hello-world/</id>
    <published>2023-05-23T12:12:58.294Z</published>
    <updated>2023-05-23T12:12:58.294Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
